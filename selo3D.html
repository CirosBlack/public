<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Prompts para Selos 3D & 2D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100vh; /* Define a altura total da viewport */
            overflow: hidden; /* Impede a rolagem da página principal */
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        .prompt-card, .history-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .prompt-card:hover, .history-card:hover {
            transform: translateY(-5px);
        }
        .reuse-btn:hover {
            background-color: #3b82f6; /* Azul mais claro */
        }
        input[type="radio"]:checked {
            box-shadow: 0 0 0 2px #4f46e5;
        }
        .btn-secondary {
            background-color: #4b5563;
        }
        .btn-secondary:hover {
            background-color: #6b7280;
        }
        
        /* Estilos para o scroll vertical das colunas */
        #form-column, #output-column {
            overflow-y: auto;
            padding-right: 12px;
        }

        /* Estilização da barra de rolagem */
        #form-column::-webkit-scrollbar, #output-column::-webkit-scrollbar {
            width: 8px;
        }
        #form-column::-webkit-scrollbar-track, #output-column::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 10px;
        }
        #form-column::-webkit-scrollbar-thumb, #output-column::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 10px;
        }
        #form-column::-webkit-scrollbar-thumb:hover, #output-column::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        .filter-btn.active {
            background-color: #4f46e5;
            color: white;
        }
        textarea {
            resize: none; /* Impede que o usuário redimensione manualmente */
        }
        /* Oculta a barra de rolagem do textarea de detalhes */
        #details-input::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        #details-input {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
    </style>
</head>
<body class="bg-gray-900 text-white p-4">

    <div class="w-full bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-10 h-full flex flex-col">
        
        <div id="content-grid" class="grid grid-cols-1 lg:grid-cols-2 gap-x-12 flex-grow overflow-hidden">
            
            <!-- Coluna da Esquerda: Formulário e Histórico (com scroll) -->
            <div id="form-column">
                <!-- Formulário de Entrada -->
                <div class="space-y-6 mb-8">
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="text-input" class="block text-sm font-bold text-gray-300 mb-2">TEXTO PRINCIPAL (OPCIONAL)</label>
                            <input type="text" id="text-input" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-4 py-2 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                        </div>
                        <div>
                            <label for="theme-input" class="block text-sm font-bold text-gray-300 mb-2">TEMA</label>
                            <input type="text" id="theme-input" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-4 py-2 focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                        </div>
                    </div>
                    
                    <!-- Controles de Dimensão -->
                    <div class="grid grid-cols-2 gap-x-8 gap-y-6">
                        <div>
                            <label class="block text-sm font-bold text-gray-300 mb-2 text-center">DIMENSÃO DO TEXTO</label>
                            <div class="flex space-x-4">
                                <label for="text-dim-3d" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input id="text-dim-3d" name="text-dimension" type="radio" value="3d" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500" checked><span class="ml-3 text-sm">3D</span></label>
                                <label for="text-dim-2d" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input id="text-dim-2d" name="text-dimension" type="radio" value="2d" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-3 text-sm">2D</span></label>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-bold text-gray-300 mb-2 text-center">DIMENSÃO DA COMPOSIÇÃO</label>
                            <div class="flex space-x-4">
                                <label for="comp-dim-3d" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input id="comp-dim-3d" name="comp-dimension" type="radio" value="3d" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500" checked><span class="ml-3 text-sm">3D</span></label>
                                <label for="comp-dim-2d" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input id="comp-dim-2d" name="comp-dimension" type="radio" value="2d" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-3 text-sm">2D</span></label>
                            </div>
                        </div>
                    </div>

                    <!-- Estilos Artísticos, Ângulo e Fundo -->
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                        <div>
                            <label class="block text-sm font-bold text-gray-300 mb-2 text-center">ESTILO ARTÍSTICO</label>
                            <div class="space-y-2">
                                <label for="style-realistic" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600"><input id="style-realistic" name="style-option" type="radio" value="realistic" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500" checked><span class="ml-3 text-sm text-gray-300">Realista</span></label>
                                <label for="style-cartoon" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600"><input id="style-cartoon" name="style-option" type="radio" value="cartoon" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-3 text-sm text-gray-300">Cartoon</span></label>
                                <label for="style-illustration" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600"><input id="style-illustration" name="style-option" type="radio" value="illustration" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-3 text-sm text-gray-300">Ilustração</span></label>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-bold text-gray-300 mb-2 text-center">ÂNGULO E POSIÇÃO</label>
                            <div class="space-y-2">
                                <!-- Angle options -->
                                <div class="flex space-x-2">
                                    <label for="angle-frontal" class="flex items-center p-2 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input id="angle-frontal" name="angle-option" type="radio" value="frontal" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-2 text-sm">Frontal</span></label>
                                    <label for="angle-perspective" class="flex items-center p-2 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input id="angle-perspective" name="angle-option" type="radio" value="perspective" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-2 text-sm">Perspectiva</span></label>
                                </div>
                                <!-- Rotation direction options -->
                                <div class="flex space-x-2">
                                    <label for="rot-dir" class="flex items-center p-2 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center">
                                        <input id="rot-dir" name="rotation-direction" type="radio" value="direita" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500">
                                        <span class="ml-2 text-sm">Direita</span>
                                    </label>
                                    <label for="rot-esq" class="flex items-center p-2 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center">
                                        <input id="rot-esq" name="rotation-direction" type="radio" value="esquerda" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500">
                                        <span class="ml-2 text-sm">Esquerda</span>
                                    </label>
                                </div>
                                <!-- Rotation degrees input -->
                                <input type="number" id="rotation-degrees" placeholder="Graus" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-indigo-500 focus:outline-none">
                            </div>
                        </div>
                         <div>
                            <label class="block text-sm font-bold text-gray-300 mb-2 text-center">FUNDO</label>
                            <div class="space-y-2">
                                <label for="bg-black" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600"><input id="bg-black" name="background-option" type="radio" value="solid black background" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-2 text-sm text-gray-300">Preto</span></label>
                                <label for="bg-white" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600"><input id="bg-white" name="background-option" type="radio" value="solid white background" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-2 text-sm text-gray-300">Branco</span></label>
                                <label for="bg-transparent" class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600"><input id="bg-transparent" name="background-option" type="radio" value="transparent background (.png)" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-2 text-sm text-gray-300">Transparente</span></label>
                            </div>
                        </div>
                    </div>

                    <!-- Seção de Upload de Imagem -->
                    <div>
                        <label class="block text-sm font-bold text-gray-300 mb-2">ENVIE UMA IMAGEM DE REFERÊNCIA</label>
                        <label for="image-upload" class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg flex items-center justify-center transition-colors hover:bg-blue-700 cursor-pointer">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                            ESCOLHER ARQUIVO
                        </label>
                        <input type="file" id="image-upload" accept="image/*" class="hidden">
                        <div id="image-preview-container" class="mt-4 hidden">
                            <img id="image-preview" src="#" alt="Pré-visualização da Imagem" class="w-full h-auto rounded-lg"/>
                        </div>
                    </div>
                    
                    <!-- Detalhes Adicionais e Botões de IA -->
                    <div>
                        <label for="details-input" class="block text-sm font-bold text-gray-300 mb-2">DETALHES ADICIONAIS</label>
                        <div class="flex items-center space-x-4 mb-3">
                            <button id="describe-image-btn" class="flex-1 bg-teal-500 hover:bg-teal-600 text-white font-semibold py-3 rounded-lg flex items-center justify-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap">
                                <svg id="describe-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" /></svg>
                                <svg id="describe-loader" class="animate-spin h-5 w-5 mr-2 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                                <span id="describe-btn-text">DESCREVER IMAGEM</span>
                            </button>
                            <button id="generate-ideas-btn" class="flex-1 text-sm bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-semibold py-3 rounded-lg flex items-center justify-center transition-colors">
                                <svg id="idea-icon" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" /></svg>
                                <svg id="idea-loader" class="animate-spin h-4 w-4 mr-1 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                                <svg id="idea-check" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 hidden text-green-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>
                                <span id="idea-btn-text">GERAR IDEIAS</span>
                            </button>
                        </div>
                        
                        <!-- Botões de Ação Movidos -->
                        <div class="flex space-x-4 my-4">
                            <button id="clear-btn" class="flex-1 btn-secondary text-white font-semibold py-3 rounded-lg shadow-lg hover:bg-gray-600 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50">LIMPAR</button>
                            <button id="generate-btn" class="flex-1 bg-indigo-600 text-white font-semibold py-3 rounded-lg shadow-lg hover:bg-indigo-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50">GERAR PROMPTS</button>
                        </div>

                        <textarea id="details-input" rows="2" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-4 py-2 focus:ring-2 focus:ring-indigo-500 focus:outline-none"></textarea>
                    </div>
                </div>

                <!-- Seção de Histórico -->
                <div id="history-section" class="hidden">
                    <div class="flex justify-start items-center mb-4">
                         <h2 class="text-xl font-bold text-gray-300">HISTÓRICO DE PROMPTS</h2>
                    </div>
                    <div id="history-container" class="space-y-4"></div>
                </div>
            </div>
            
            <!-- Coluna da Direita: Saída (com scroll) -->
            <div id="output-column">
                <!-- Botões de Filtro -->
                <div id="filter-buttons-wrapper" class="hidden mb-6">
                    <h3 id="filter-title" class="text-left text-xl font-bold text-gray-300 mb-4">NAVEGAR PARA:</h3>
                    <div id="filter-buttons" class="flex flex-wrap justify-start gap-3"></div>
                </div>

                <!-- Seção de Saída -->
                <div id="output-section">
                    <div id="initial-message" class="text-center text-gray-500 mt-20">
                        <p>Seus prompts aparecerão aqui...</p>
                    </div>
                    <div id="loader" class="text-center hidden"><svg class="animate-spin h-8 w-8 text-indigo-400 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><p id="loader-text" class="mt-2 text-gray-400">Gerando prompts...</p></div>
                    <h2 id="prompts-label" class="hidden text-xl font-bold text-gray-300 mb-4">PROMPTS</h2>
                    <div id="prompts-container" class="space-y-6"></div>
                    <div id="error-message" class="text-center text-red-400 mt-4 hidden"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Elementos do DOM
        const generateBtn = document.getElementById('generate-btn');
        const clearBtn = document.getElementById('clear-btn');
        const generateIdeasBtn = document.getElementById('generate-ideas-btn');
        const ideaIcon = document.getElementById('idea-icon');
        const ideaLoader = document.getElementById('idea-loader');
        const ideaCheck = document.getElementById('idea-check');
        const ideaBtnText = document.getElementById('idea-btn-text');
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        const promptsContainer = document.getElementById('prompts-container');
        const promptsLabel = document.getElementById('prompts-label');
        const filterButtonsContainer = document.getElementById('filter-buttons');
        const filterButtonsWrapper = document.getElementById('filter-buttons-wrapper');
        const filterTitle = document.getElementById('filter-title');
        const errorMessage = document.getElementById('error-message');
        const historySection = document.getElementById('history-section');
        const historyContainer = document.getElementById('history-container');
        const initialMessage = document.getElementById('initial-message');
        
        // Elementos de Upload de Imagem
        const imageUpload = document.getElementById('image-upload');
        const describeImageBtn = document.getElementById('describe-image-btn');
        const describeIcon = document.getElementById('describe-icon');
        const describeLoader = document.getElementById('describe-loader');
        const describeBtnText = document.getElementById('describe-btn-text');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');

        // Inputs
        const textInput = document.getElementById('text-input');
        const themeInput = document.getElementById('theme-input');
        const detailsInput = document.getElementById('details-input');
        const rotationDegrees = document.getElementById('rotation-degrees');

        // Variáveis globais para armazenar dados da imagem pré-processada
        let currentBase64ImageData = null;
        let currentMimeType = null;
        
        const HISTORY_KEY = 'promptHistory3D';
        
        // Funções de Histórico
        const getHistory = () => JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
        
        const saveToHistory = (entry) => {
            let history = getHistory();
            history.unshift(entry);
            history = history.slice(0, 5); // Manter apenas os últimos 5
            localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
            displayHistory();
        };

        const displayHistory = () => {
            const history = getHistory();
            if (history.length === 0) {
                historySection.classList.add('hidden');
                return;
            }
            historySection.classList.remove('hidden');
            historyContainer.innerHTML = '';
            history.forEach((item, index) => {
                const card = document.createElement('div');
                card.className = 'history-card bg-gray-700 p-4 rounded-lg shadow-md flex justify-between items-center';
                
                const dimensionLabel = `Texto ${item.textDimension.toUpperCase()} / Comp ${item.compDimension.toUpperCase()}`;

                card.innerHTML = `
                    <div class="flex-grow">
                        <p class="font-semibold text-indigo-400">${item.text ? `${item.text} - ` : ''}${item.theme} <span class="text-xs font-normal text-gray-400">(${dimensionLabel})</span></p>
                        <p class="text-xs text-gray-400">Estilo: ${item.style} | Fundo: ${item.background.split(' ')[1] || 'N/A'}</p>
                    </div>
                    <div class="flex items-center space-x-3">
                        <button class="reuse-btn bg-blue-600 text-white text-sm font-medium py-2 px-3 rounded-md" data-index="${index}">REUSAR</button>
                        <button class="delete-prompt-btn bg-red-600 text-white p-2 rounded-md hover:bg-red-700" data-index="${index}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                        </button>
                    </div>
                `;
                historyContainer.appendChild(card);
            });
        };
        
        const deleteHistoryItem = (index) => {
            let history = getHistory();
            history.splice(index, 1);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
            displayHistory();
        };

        const reuseHistoryItem = (index) => {
            const history = getHistory();
            const item = history[index];
            if (!item) return;

            textInput.value = item.text;
            themeInput.value = item.theme;
            detailsInput.value = item.details;
            
            document.querySelectorAll('input[name="angle-option"]').forEach(r => r.checked = false);
            if (item.angle) {
                const angleRadio = document.querySelector(`input[name="angle-option"][value="${item.angle}"]`);
                if (angleRadio) angleRadio.checked = true;
            }
            
            document.querySelectorAll('input[name="rotation-direction"]').forEach(r => r.checked = false);
            if (item.rotation) {
                const parts = item.rotation.match(/(\d+)\s*graus\s*à\s*(direita|esquerda)/i);
                if (parts) {
                    rotationDegrees.value = parts[1];
                    const directionRadio = document.querySelector(`input[name="rotation-direction"][value="${parts[2].toLowerCase()}"]`);
                    if(directionRadio) directionRadio.checked = true;
                } else {
                     rotationDegrees.value = '';
                }
            } else {
                rotationDegrees.value = '';
            }
            
            document.querySelector(`input[name="text-dimension"][value="${item.textDimension}"]`).checked = true;
            document.querySelector(`input[name="comp-dimension"][value="${item.compDimension}"]`).checked = true;
            
            const styleRadio = document.querySelector(`input[name="style-option"][value="${item.style}"]`);
            if (styleRadio) {
                styleRadio.checked = true;
            } else {
                document.querySelector('input[name="style-option"][value="realistic"]').checked = true; // Default to realistic
            }
            
            document.querySelectorAll('input[name="background-option"]').forEach(r => r.checked = false);
            if (item.background && item.background !== 'designer\'s choice') {
                const bgRadio = document.querySelector(`input[name="background-option"][value="${item.background}"]`);
                if (bgRadio) bgRadio.checked = true;
            }
            updateIdeaButtonText();
        };

        historyContainer.addEventListener('click', (e) => {
            const targetButton = e.target.closest('button');
            if (!targetButton) return;

            const index = targetButton.dataset.index;
            if (targetButton.classList.contains('reuse-btn')) {
                reuseHistoryItem(index);
            } else if (targetButton.classList.contains('delete-prompt-btn')) {
                deleteHistoryItem(index);
            }
        });

        // Limpar Formulário
        const clearForm = () => {
            textInput.value = '';
            themeInput.value = '';
            detailsInput.value = '';
            rotationDegrees.value = '';
            detailsInput.style.height = '';
            
            document.querySelectorAll('input[name="background-option"]').forEach(radio => radio.checked = false);
            document.querySelectorAll('input[name="angle-option"]').forEach(radio => radio.checked = false);
            document.querySelectorAll('input[name="rotation-direction"]').forEach(radio => radio.checked = false);

            document.querySelector('input[value="3d"][name="text-dimension"]').checked = true;
            document.querySelector('input[value="3d"][name="comp-dimension"]').checked = true;
            document.querySelector('input[value="realistic"]').checked = true;

            promptsContainer.innerHTML = '';
            filterButtonsContainer.innerHTML = '';
            filterButtonsWrapper.classList.add('hidden');
            promptsLabel.classList.add('hidden');
            errorMessage.classList.add('hidden');
            initialMessage.classList.remove('hidden');
            
            imagePreviewContainer.classList.add('hidden');
            imageUpload.value = '';
            currentBase64ImageData = null;
            currentMimeType = null;
            updateIdeaButtonText();
        };

        clearBtn.addEventListener('click', clearForm);

        function getBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = (event) => {
                    console.error("FileReader error object:", event);
                    console.error("Detalhes do erro do FileReader:", reader.error);
                    reject(new Error('Não foi possível ler o arquivo. Pode estar corrompido ou o navegador bloqueou a leitura.'));
                };
                reader.readAsDataURL(file);
            });
        }

        imageUpload.addEventListener('change', async function() {
            currentBase64ImageData = null;
            currentMimeType = null;
            if (this.files && this.files[0]) {
                const file = this.files[0];
                const reader = new FileReader();
                reader.onload = (e) => {
                    imagePreview.setAttribute('src', e.target.result);
                    imagePreviewContainer.classList.remove('hidden');
                };
                reader.readAsDataURL(file);

                try {
                    currentBase64ImageData = await getBase64(file);
                    currentMimeType = file.type;
                    errorMessage.classList.add('hidden');
                } catch (error) {
                    console.error("Erro ao pré-processar a imagem:", error);
                    errorMessage.textContent = error.message || "Não foi possível ler o arquivo selecionado.";
                    errorMessage.classList.remove('hidden');
                    imagePreview.setAttribute('src', '#');
                    imagePreviewContainer.classList.add('hidden');
                }
            }
        });
        
        const adjustTextareaHeight = (element) => {
            element.style.height = 'auto';
            element.style.height = (element.scrollHeight) + 'px';
        };

        describeImageBtn.addEventListener('click', async () => {
            if (!currentBase64ImageData) {
                errorMessage.textContent = 'Por favor, selecione uma imagem válida primeiro.';
                errorMessage.classList.remove('hidden');
                return;
            }

            describeImageBtn.disabled = true;
            describeIcon.classList.add('hidden');
            describeLoader.classList.remove('hidden');
            describeBtnText.textContent = 'ANALISANDO...';
            errorMessage.classList.add('hidden');

            const compDimension = document.querySelector('input[name="comp-dimension"]:checked').value;
            let visionPrompt = '';
            
            if (compDimension === '2d') {
                visionPrompt = `
                    As a senior art director, perform an exhaustive analysis of the provided image to create a detailed creative brief for recreating it as a 2D sticker.
                    The output MUST be a valid JSON object with three keys: "text", "theme", and "details".

                    1.  **"text"**: Analyze the image to identify the most prominent text. Extract this text *exactly* as it appears, including capitalization and punctuation. If no text is present, return an empty string.
                    2.  **"theme"**: Based on the overall visual style, characters, and elements, define a concise, two-to-three-word theme in Portuguese.
                    3.  **"details"**: Provide a comprehensive, comma-separated list in English describing every visual aspect for a master illustrator. This is a professional design brief. Be specific and cover these points:
                        * **Typography Analysis:** Describe the font style (e.g., bold sans-serif, playful script, hand-drawn). Describe its visual treatment: thick outlines, drop shadows, gradients, textures within the letters.
                        * **Composition & Structure:** Describe the layout. Is it centered, asymmetrical? How do the elements frame the text? What is the overall shape of the sticker?
                        * **Characters & Mascots:** Identify any characters. Describe their style (e.g., chibi, cartoon, realistic), pose, expression, and interaction with the text.
                        * **Supporting Elements:** List all other decorative elements (e.g., flowers, stars, splash effects, background patterns).
                        * **Color Palette & Line Art:** List the dominant colors. Describe the line art style (e.g., clean vector lines, rough sketchy outlines, no outlines).
                `;
            } else { // 3D
                visionPrompt = `
                    As a senior 3D art director, perform an exhaustive analysis of the provided image to create a detailed creative brief for recreating it as a photorealistic 3D emblem.
                    The output MUST be a valid JSON object with three keys: "text", "theme", and "details".

                    1.  **"text"**: Analyze the image to identify the most prominent text. Extract this text *exactly* as it appears, including capitalization and punctuation. If no text is present, return an empty string.
                    2.  **"theme"**: Based on the overall visual style, characters, and elements, define a concise, two-to-three-word theme in Portuguese.
                    3.  **"details"**: Provide an exhaustive, comma-separated list in English describing every visual aspect. This is a creative brief for a master 3D artist. Be specific and cover these points:
                        * **Typography Analysis (CRITICAL):** Describe the font of the extracted text. Is it serif, sans-serif, script? What is its weight (bold, light)? Describe its 3D properties: extrusion depth, bevel style (rounded, sharp), outlines, inlays.
                        * **Composition & Structure:** Describe the overall shape of the emblem. How are the elements layered? What forms the backplate or container for the text?
                        * **Characters & Mascots:** Identify any characters. Describe their pose, expression, and interaction with the text.
                        * **Supporting Elements:** List all other decorative elements (shapes, swirls, icons, etc.) and their materials.
                        * **Color Palette:** List the primary, secondary, and accent colors.
                        * **Lighting & Materials:** Describe the lighting setup (e.g., dramatic top-down key light, soft ambient occlusion, colored rim lights) and the textures of all surfaces (PBR materials like glossy, matte, metallic).
                `;
            }
            
            try {
                const base64ImageData = currentBase64ImageData;
                const apiKey = "AIzaSyAMc2t1NsMkkWS9nFNTrE5kijf-gWEKMuM"; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const payload = {
                    contents: [{ parts: [{ text: visionPrompt }, { inlineData: { mimeType: currentMimeType, data: base64ImageData } }] }],
                    generationConfig: { responseMimeType: "application/json" }
                };
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();
                const descriptionText = result.candidates[0].content.parts[0].text;
                const descriptionJson = JSON.parse(descriptionText);
                textInput.value = descriptionJson.text || '';
                themeInput.value = descriptionJson.theme || '';
                detailsInput.value = descriptionJson.details || '';
                adjustTextareaHeight(detailsInput);
                updateIdeaButtonText();
                generateBtn.click(); // Ativa o botão de gerar prompts
            } catch (error) {
                console.error("Erro ao descrever a imagem:", error);
                errorMessage.textContent = error.message || "Não foi possível analisar a imagem. Tente um arquivo diferente.";
                errorMessage.classList.remove('hidden');
            } finally {
                describeImageBtn.disabled = false;
                describeIcon.classList.remove('hidden');
                describeLoader.classList.add('hidden');
                describeBtnText.textContent = 'DESCREVER IMAGEM';
            }
        });
        
        const updateIdeaButtonText = () => {
            if (detailsInput.value.trim() !== '') {
                ideaBtnText.textContent = 'MELHORAR IDEIAS';
            } else {
                ideaBtnText.textContent = 'GERAR IDEIAS';
            }
        };

        detailsInput.addEventListener('input', updateIdeaButtonText);

        generateIdeasBtn.addEventListener('click', async () => {
            const file = imageUpload.files[0];
            const theme = themeInput.value;
            const text = textInput.value;
            const existingDetails = detailsInput.value.trim();
            const textDimension = document.querySelector('input[name="text-dimension"]:checked').value;
            const compDimension = document.querySelector('input[name="comp-dimension"]:checked').value;
            const style = document.querySelector('input[name="style-option"]:checked').value;
            const angle = document.querySelector('input[name="angle-option"]:checked')?.value;
            const degrees = rotationDegrees.value;
            let rotation = '';
            if (degrees && document.querySelector('input[name="rotation-direction"]:checked')) {
                const direction = document.querySelector('input[name="rotation-direction"]:checked').value;
                rotation = `${degrees} graus à ${direction}`;
            }
            const background = document.querySelector('input[name="background-option"]:checked')?.value || 'designer\'s choice';


            // Inicia o estado de carregamento da UI
            generateIdeasBtn.disabled = true;
            ideaLoader.classList.remove('hidden');
            ideaIcon.classList.add('hidden');
            ideaCheck.classList.add('hidden');
            errorMessage.classList.add('hidden');

            let ideasPrompt = '';
            let payload;
            const apiKey = "AIzaSyAMc2t1NsMkkWS9nFNTrE5kijf-gWEKMuM"; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            if (file) {
                ideaBtnText.textContent = 'ANALISANDO...';
                if (!theme) {
                     errorMessage.textContent = 'Para gerar ideias a partir de uma imagem, preencha o campo "Tema".';
                     errorMessage.classList.remove('hidden');
                     generateIdeasBtn.disabled = false;
                     ideaLoader.classList.add('hidden');
                     ideaIcon.classList.remove('hidden');
                     updateIdeaButtonText();
                     return;
                }
                if (!currentBase64ImageData) {
                    errorMessage.textContent = 'A imagem selecionada não pôde ser lida. Por favor, tente novamente.';
                    errorMessage.classList.remove('hidden');
                    generateIdeasBtn.disabled = false;
                    ideaLoader.classList.add('hidden');
                    ideaIcon.classList.remove('hidden');
                    updateIdeaButtonText();
                    return;
                }

                const base64ImageData = currentBase64ImageData;
                const mainTextForIdeas = text ? `- Main Text for the new concept: "${text}"` : `- Main Concept: A purely illustrative design without text.`;
                const typographyInstruction = text ? `- Similar but New Typography: Propose a different font style for the text "${text}" that still fits the theme.` : `- Illustrative Focus: Since there is no text, focus your description on the main illustrative elements that will be the centerpiece of the design.`;

                ideasPrompt = `
                    As an expert creative director specializing in variations, your task is a two-step process to generate a new, creative but similar variation inspired by a reference image.

                    Inputs for your consideration:
                    - Reference Image: [Image Data Attached]
                    ${mainTextForIdeas}
                    - Core Theme for the new concept: "${theme}"

                    Step 1: Ultra-Detailed Internal Analysis (Do not output this part).
                    First, perform an exhaustive technical and artistic analysis of the provided image. Mentally deconstruct its context, typography (style, 3D/2D effects), color palette, lighting scheme (highlights, shadows), overall structure (badge, logo, emblem), base shape, lines, curves, and all additional elements. Note the background type.

                    Step 2: Create a Similar Variation (This is your output).
                    Based on your detailed internal analysis, create a new design brief for a **similar but distinct variation**. Your new brief must be a single, highly detailed paragraph in ENGLISH that describes these specific modifications:
                    ${typographyInstruction}
                    - Similar but New Composition: Keep the core elements but change their form. Crucially, reinvent the base shape with more creativity; the base can be a complex geometric form or it can be formed from thematic elements themselves. Change its materials as well.
                    - Similar but New Atmosphere: Adjust the lighting and color palette slightly to create a different mood while staying true to the original theme.

                    Final Output:
                    Produce a single, cohesive, and highly detailed paragraph in ENGLISH that describes this new, similar variation, ready to be used as a prompt.
                `;
                payload = {
                    contents: [{ parts: [{ text: ideasPrompt }, { inlineData: { mimeType: currentMimeType, data: base64ImageData } }] }]
                };
            } else {
                if (!theme || (!text && !existingDetails)) {
                    errorMessage.textContent = 'Preencha o "Tema" e também o "Texto Principal" ou os "Detalhes Adicionais" para gerar ideias.';
                    errorMessage.classList.remove('hidden');
                    generateIdeasBtn.disabled = false;
                    ideaLoader.classList.add('hidden');
                    ideaIcon.classList.remove('hidden');
                    updateIdeaButtonText();
                    return;
                }
                
                ideaBtnText.textContent = existingDetails ? 'MELHORANDO...' : 'GERANDO...';
                
                if (existingDetails) {
                    const mainTextContext = text ? `- Main Text: "${text}"` : `- Main Concept: No text, purely illustrative.`;
                    ideasPrompt = `
                        As an elite-level creative director, your task is to take the user's initial concept and elevate it into an incredibly detailed and cohesive final design brief, using all provided context.

                        User's Initial Idea (The Foundation):
                        "${existingDetails}"

                        Context for Enhancement (Your Guiding Principles):
                        ${mainTextContext}
                        - Core Theme: "${theme}"
                        - Text Dimension: "${textDimension}"
                        - Composition Dimension: "${compDimension}"
                        - Artistic Style: "${style}"
                        - View Angle: "${angle || 'Not specified'}"
                        - Text Rotation: "${rotation || 'Not specified'}"
                        - Background: "${background}"

                        Your Mission:
                        Refine and expand upon the user's core idea. Focus on:
                        1.  Composition: Make the arrangement more dynamic, aligning with the specified angle and rotation.
                        2.  Texture & Materials: Enhance surface descriptions to be more vivid and tactile.
                        3.  Colors & Lighting: Refine the color palette and describe the lighting in greater detail to create a specific mood.
                        4.  Cohesion: Ensure all elements work together perfectly to express the "${theme}".

                        Final Output:
                        Produce a single, cohesive, and incredibly detailed paragraph in ENGLISH that represents the improved and finalized creative brief.
                    `;
                } else {
                    const mainTextSpec = text ? `- Main Text: "${text}"` : `- Main Concept: No text, purely illustrative.`;
                    const typographyTask = text
                        ? `2.  Thematic Typography: Invent a highly creative and thematic font style for the text "${text}". The letters themselves should be made of materials or have textures that embody the "${theme}". Describe this in detail.`
                        : `2.  Central Illustration: Since there is no text, invent a central, iconic character or symbol that powerfully represents the "${theme}". This will be the main focus of the emblem. Describe it in detail.`;

                    ideasPrompt = `
                        As an elite-level creative director, your task is to conceptualize a complete and ultra-detailed design brief for a badge, logo, or emblem from scratch, based on the user's specifications.

                        User's Specifications:
                        ${mainTextSpec}
                        - Core Theme: "${theme}"
                        - Text Dimension: "${textDimension}"
                        - Composition Dimension: "${compDimension}"
                        - Artistic Style: "${style}"
                        - View Angle: "${angle || 'Not specified'}"
                        - Text Rotation: "${rotation || 'Not specified'}"
                        - Background: "${background}"

                        Your Task:
                        Generate a single, cohesive paragraph in ENGLISH that describes a visually stunning badge, logo, or emblem, synthesizing all specifications:
                        1.  Core Concept: The final piece must be a self-contained badge, logo, or emblem.
                        ${typographyTask}
                        3.  Creative Base Design: Design a unique and complex base or frame for the emblem. The base can be a complex geometric form or formed from thematic elements.
                        4.  Rich Composition: Describe how all elements are integrated into this base to create a rich, layered composition.
                        5.  Style and Realism: The aesthetic must match the selected "${style}".
                        6.  Lighting and Texture: Describe the lighting setup and surface textures to enhance the theme.
                        7.  Angle and Position: Incorporate the specified view angle and text rotation.

                        Final Output:
                        A single, detailed paragraph in ENGLISH that can be used as a high-quality prompt.
                    `;
                }
                payload = { contents: [{ parts: [{ text: ideasPrompt }] }] };
            }

            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();
                detailsInput.value = result.candidates[0].content.parts[0].text.trim();
                adjustTextareaHeight(detailsInput);
                ideaCheck.classList.remove('hidden');
                ideaBtnText.textContent = 'IDEIA GERADA!';
                updateIdeaButtonText();
                generateBtn.click();
            } catch (error) {
                console.error("Erro ao gerar/melhorar ideias:", error);
                errorMessage.textContent = "Não foi possível processar as ideias. Tente novamente.";
                errorMessage.classList.remove('hidden');
                updateIdeaButtonText();
            } finally {
                generateIdeasBtn.disabled = false;
                ideaLoader.classList.add('hidden');
            }
        });
        
        const copyToClipboard = (text, buttonElement) => {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                if (buttonElement) {
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = 'COPIADO!';
                    setTimeout(() => { buttonElement.textContent = originalText; }, 2000);
                }
            } catch (err) {
                console.error('Falha ao copiar texto: ', err);
                if (buttonElement) {
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = 'ERRO!';
                    setTimeout(() => { buttonElement.textContent = originalText; }, 2000);
                }
            }
            document.body.removeChild(textarea);
        };

        generateBtn.addEventListener('click', async () => {
            ideaCheck.classList.add('hidden');
            ideaIcon.classList.remove('hidden');
            updateIdeaButtonText();

            const text = textInput.value;
            const theme = themeInput.value;
            const details = detailsInput.value;
            const textDimension = document.querySelector('input[name="text-dimension"]:checked').value;
            const compDimension = document.querySelector('input[name="comp-dimension"]:checked').value;
            const style = document.querySelector('input[name="style-option"]:checked').value;
            const background = document.querySelector('input[name="background-option"]:checked')?.value || 'designer\'s choice';
            const angle = document.querySelector('input[name="angle-option"]:checked')?.value;
            
            const degrees = rotationDegrees.value;
            let rotation = '';
            if (degrees && document.querySelector('input[name="rotation-direction"]:checked')) {
                const direction = document.querySelector('input[name="rotation-direction"]:checked').value;
                rotation = `${degrees} graus à ${direction}`;
            }

            if (!theme || (!text && !details)) {
                errorMessage.textContent = 'Preencha o "Tema" e também o "Texto Principal" ou os "Detalhes Adicionais".';
                errorMessage.classList.remove('hidden');
                return;
            }
            
            initialMessage.classList.add('hidden');
            loader.classList.remove('hidden');
            promptsContainer.innerHTML = '';
            filterButtonsContainer.innerHTML = '';
            filterButtonsWrapper.classList.add('hidden');
            promptsLabel.classList.add('hidden');
            errorMessage.classList.add('hidden');
            
            const apiKey = "AIzaSyAMc2t1NsMkkWS9nFNTrE5kijf-gWEKMuM";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const params = { text, theme, details, style, background, textDimension, compDimension, angle, rotation, apiKey, apiUrl };

            if (textDimension === '3d' && compDimension === '3d') {
                await generate3DPrompts(params);
            } else if (textDimension === '2d' && compDimension === '2d') {
                await generate2DPrompts(params);
            } else if (textDimension === '3d' && compDimension === '2d') {
                await generateMixed3DText2DCompPrompts(params);
            } else { // 2d text, 3d comp
                await generateMixed2DText3DCompPrompts(params);
            }
        });

        async function executePromptGeneration(params, masterPrompt, keys, type) {
            const { text, theme, details, style, background, textDimension, compDimension, angle, rotation, apiKey, apiUrl } = params;
            const payload = { contents: [{ parts: [{ text: masterPrompt }] }], generationConfig: { responseMimeType: "application/json" } };
            
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();
                const responseText = result.candidates[0].content.parts[0].text;
                const generatedPrompts = JSON.parse(responseText).prompts;

                if (generatedPrompts.length !== keys.length) throw new Error(`A IA não retornou ${keys.length} prompts.`);

                promptsLabel.classList.remove('hidden');
                promptsLabel.textContent = `PROMPTS ${type}`;
                filterTitle.textContent = type.includes('3D') || type.includes('TEXTO 2D') ? 'NAVEGAR POR RENDERIZADOR:' : 'NAVEGAR POR ESTILO:';

                generatedPrompts.forEach((promptText, index) => {
                    const keyName = keys[index];
                    const card = document.createElement('div');
                    card.className = `prompt-card bg-gray-700 p-6 rounded-lg shadow-md flex-col ${index === 0 ? 'flex' : 'hidden'}`;
                    card.dataset.key = keyName;
                    card.innerHTML = `
                        <h3 class="text-xl font-semibold text-indigo-400 mb-3">${keyName.toUpperCase()}</h3>
                        <p class="prompt-text text-gray-300 flex-grow text-sm leading-relaxed">${promptText}</p>`;
                    promptsContainer.appendChild(card);
                    
                    const filterButton = document.createElement('button');
                    filterButton.className = `filter-btn bg-gray-600 text-gray-200 text-sm font-semibold py-1 px-4 rounded-md hover:bg-indigo-500 transition-colors ${index === 0 ? 'active' : ''}`;
                    filterButton.textContent = keyName.toUpperCase();
                    filterButton.dataset.targetKey = keyName;
                    filterButtonsContainer.appendChild(filterButton);
                });
                
                filterButtonsWrapper.classList.remove('hidden');
                
                saveToHistory({ text, theme, details, style, background, textDimension, compDimension, angle, rotation, prompts: generatedPrompts });

            } catch (error) {
                console.error(`Erro ao gerar prompts ${type}:`, error);
                errorMessage.textContent = `Ocorreu um erro ao gerar os prompts ${type}. Tente novamente.`;
                errorMessage.classList.remove('hidden');
            } finally {
                loader.classList.add('hidden');
            }
        }
        
        const coreDirectives = (params) => {
            let baseDirective = `
                CORE DIRECTIVES FOR A RICH COMPOSITION:
                1.  Self-Contained Design: The final result MUST be a self-contained badge emblem logo, NOT a scene or landscape.
            `;
            if (params.text) {
                baseDirective += `2. Main Text: The text "${params.text}" is the absolute centerpiece. The focus is the typographic object.\n`;
            } else {
                baseDirective += `2. No Main Text: The final result should be a purely illustrative emblem or logo without any text. The visual concept is described entirely in the "Additional Details" field.\n`;
            }

            if (params.details) {
                baseDirective += `
                3.  Source of Truth: The "Additional Details" field contains an expert description. Your primary task is to FAITHFULLY translate this description into the target style/renderer.
                4.  Adapt, Don't Invent: Use the characters, typography, and composition elements from the "Additional Details". Do NOT invent new concepts. Your creativity should be focused on adapting the existing design to the new style.
                `;
            } else {
                if (params.text) {
                     baseDirective += `
                        3.  Invent a Thematic Font Style: The typography for the text "${params.text}" must be a radical, visual representation of the theme "${params.theme}". Do not just use a standard font. Invent a new style where the letters themselves are constructed from thematic materials (e.g., for a 'Pirate' theme, letters made of weathered ship planks and gold coins).
                     `;
                }
                baseDirective += `
                4.  Include Thematic Characters: The logo MUST feature at least one character or mascot that embodies the theme. The character should interact with the text (if present) in a dynamic way (e.g., a ghost peeking from behind a 'Halloween' text).
                5.  Build a Rich Composition: The typography and character must not exist in a void. They must be the centerpiece of a rich composition of thematic elements that form the body of the emblem/seal (e.g., for 'Halloween', surround the text with carved pumpkins, spider webs, and bats).
                `;
            }
            return baseDirective.replace(/\*+/g, ''); // Remove all asterisks
        };

        const getAngleAndPositionRule = (params) => {
            let rule = '';
            if (params.angle === 'perspective') {
                rule += ` The camera view for the entire composition MUST be in a dynamic perspective angle, not a flat front view.`;
            } else if (params.angle === 'frontal'){
                rule += ` The camera view for the entire composition MUST be a direct frontal shot.`;
            }

            if (params.rotation && params.text) {
                const parts = params.rotation.match(/(\d+)\s*graus\s*à\s*(direita|esquerda)/i);
                if (parts) {
                    const degrees = parts[1];
                    const direction = parts[2].toLowerCase();
                    const rotationValue = direction === 'esquerda' ? -degrees : degrees;
                    rule += ` Within this view, the main text object ITSELF MUST be rotated ${rotationValue} degrees on its Z-axis. This rotation applies only to the text, not the entire composition or camera angle.`;
                }
            }
            return rule;
        };

        async function generate2DPrompts(params) {
            loaderText.textContent = 'Gerando 11 estilos de ilustração 2D...';
            const illustrationStyles = ['Design PSD', 'Procreate', 'Watercolor', 'Anime/Manga', 'Vintage Cartoon', 'Sticker Style', 'Hearthstone', 'Arcane', 'Guilty Gear', 'Genshin Impact', 'Tower of Fantasy'];
            const backgroundRule = params.background.includes('designer') ? `Creative freedom for background.` : `Background MUST be: "${params.background}". For "transparent", use "isolated on white background, png".`;
            const angleAndPositionRule = getAngleAndPositionRule(params);
            const mainTextDirective = params.text ? `Main Text: "${params.text}",` : `Main Concept (No Text): Focus on the details provided,`;
            const themeDirective = params.text ? `Theme: "${params.theme}",` : '';
            const masterPrompt = `Objective: Generate 11 distinct prompts for a 2D image AI to create a self-contained badge emblem logo. ${mainTextDirective} ${themeDirective} Details: "${params.details}". ${coreDirectives(params)} Create 11 prompts for these styles: ${illustrationStyles.join(', ')}. Adapt the core concept to each style's conventions (e.g., for 'Procreate', describe a digital painting look with rich textures; for 'Sticker Style', describe a die-cut look with a thick white border; for 'Hearthstone', describe a highly detailed 2D cartoon-fantasy digital painting with vibrant, saturated colors, soft outlines, delicate shadows, and dramatic lighting, mimicking the polished, epic, and magical art style of the game Hearthstone; for 'Arcane', describe a detailed and cinematic 2D digital painting in the style of the series Arcane: League of Legends, featuring rich textures, visible brushstrokes, intense yet harmonious colors, and dramatic, cinematic lighting with strong contrasts, conveying emotion and intensity with stylized realism; for 'Guilty Gear', describe a stylized and dynamic 2D digital art piece that simulates 3D cell shading, in the style of Guilty Gear: STRIVE, with strong lines, vibrant colors, and marked anime-style shading, featuring a dramatic, high-energy pose, cinematic lighting, and exaggerated expressiveness; for 'Genshin Impact', describe a highly detailed fantasy anime-style illustration with soft, vibrant colors, delicate digital painting, atmospheric lighting, and fine lines, conveying a magical, poetic, and ethereal feel with ornate fantasy details and a polished look; for 'Tower of Fantasy', describe a highly detailed futuristic anime-style illustration with clean lines, vibrant and saturated colors, clear lighting, and smooth shading, mixing fantasy and technology with stylized outfits, tech armor, and a modern, polished sci-fi aesthetic). ${angleAndPositionRule} Background rule: ${backgroundRule}. Output Format: JSON with a "prompts" array of 11 strings.`;
            await executePromptGeneration(params, masterPrompt, illustrationStyles, '2D');
        }

        async function generate3DPrompts(params) {
            loaderText.textContent = 'Gerando prompts 3D...';
            const renderers = ['V-Ray', 'Lumion', 'Twinmotion', 'Enscape', 'D5 Render', 'Unreal Engine 5', 'Hyperion Render'];
            const backgroundRule = params.background.includes('designer') ? `Creative freedom for background.` : `Background MUST be: "${params.background}".`;
            const angleAndPositionRule = getAngleAndPositionRule(params);
            const mainTextDirective = params.text ? `Main Text: "${params.text}",` : `Main Concept (No Text): Focus on the details provided,`;
            const themeDirective = params.text ? `Theme: "${params.theme}",` : '';
            const masterPrompt = `Objective: Generate 7 professional prompts for 3D renderers to create a self-contained badge emblem logo. ${mainTextDirective} ${themeDirective} Details: "${params.details}". ${coreDirectives(params)} Create 7 prompts for these renderers: ${renderers.join(', ')}. For 'Hyperion Render', describe a prompt that combines the hyper-detailed organic sculpting of ZBrush with the photorealistic deferred rendering, global illumination, and advanced material properties (PBR, displacement) of Unreal Engine 5, mentioning the use of the Movie Render Queue for final output. ${angleAndPositionRule} Background rule: ${backgroundRule}. Output Format: JSON with a "prompts" array of 7 strings.`;
            await executePromptGeneration(params, masterPrompt, renderers, '3D');
        }

        async function generateMixed3DText2DCompPrompts(params) {
            loaderText.textContent = 'Gerando prompts mistos (Texto 3D / Comp. 2D)...';
            const illustrationStyles = ['Design PSD', 'Procreate', 'Watercolor', 'Anime/Manga', 'Vintage Cartoon', 'Sticker Style', 'Hearthstone', 'Arcane', 'Guilty Gear', 'Genshin Impact', 'Tower of Fantasy'];
            const backgroundRule = params.background.includes('designer') ? `Creative freedom for background.` : `Background MUST be: "${params.background}". For "transparent", use "isolated on white background, png".`;
            const angleAndPositionRule = getAngleAndPositionRule(params);
            const mainTextDirective = params.text ? `3D Main Text: "${params.text}",` : `Main Concept (No Text): Focus on the details provided,`;
            const themeDirective = params.text ? `2D Theme: "${params.theme}",` : '';
            const masterPrompt = `Objective: Generate 11 prompts for a 2D image AI, creating a "trompe-l'oeil" effect self-contained badge emblem logo. ${mainTextDirective} ${themeDirective} Details: "${params.details}". ${coreDirectives(params)} The text must be described as a photorealistic 3D object, while the characters and composition elements must be 2D. Create 11 prompts for these 2D composition styles: ${illustrationStyles.join(', ')}. Emphasize the 3D text vs 2D background contrast (e.g., for 'Hearthstone', describe a highly detailed 2D cartoon-fantasy digital painting with vibrant, saturated colors, soft outlines, delicate shadows, and dramatic lighting, mimicking the polished, epic, and magical art style of the game Hearthstone; for 'Arcane', describe a detailed and cinematic 2D digital painting in the style of the series Arcane: League of Legends, featuring rich textures, visible brushstrokes, intense yet harmonious colors, and dramatic, cinematic lighting with strong contrasts, conveying emotion and intensity with stylized realism; for 'Guilty Gear', describe a stylized and dynamic 2D digital art piece that simulates 3D cell shading, in the style of Guilty Gear: STRIVE, with strong lines, vibrant colors, and marked anime-style shading, featuring a dramatic, high-energy pose, cinematic lighting, and exaggerated expressiveness; for 'Genshin Impact', describe a highly detailed fantasy anime-style illustration with soft, vibrant colors, delicate digital painting, atmospheric lighting, and fine lines, conveying a magical, poetic, and ethereal feel with ornate fantasy details and a polished look; for 'Tower of Fantasy', describe a highly detailed futuristic anime-style illustration with clean lines, vibrant and saturated colors, clear lighting, and smooth shading, mixing fantasy and technology with stylized outfits, tech armor, and a modern, polished sci-fi aesthetic). ${angleAndPositionRule} Background rule: ${backgroundRule}. Output Format: JSON with a "prompts" array of 11 strings.`;
            await executePromptGeneration(params, masterPrompt, illustrationStyles, 'MISTO (TEXTO 3D)');
        }

        async function generateMixed2DText3DCompPrompts(params) {
            loaderText.textContent = 'Gerando prompts mistos (Texto 2D / Comp. 3D)...';
            const renderers = ['V-Ray', 'Lumion', 'Twinmotion', 'Enscape', 'D5 Render', 'Unreal Engine 5', 'Hyperion Render'];
            const backgroundRule = params.background.includes('designer') ? `Creative freedom for background.` : `Background MUST be: "${params.background}".`;
            const angleAndPositionRule = getAngleAndPositionRule(params);
            const mainTextDirective = params.text ? `2D Main Text: "${params.text}",` : `Main Concept (No Text): Focus on the details provided,`;
            const themeDirective = params.text ? `3D Theme: "${params.theme}",` : '';
            const masterPrompt = `Objective: Generate 7 prompts for 3D renderers to create a self-contained badge emblem logo. ${mainTextDirective} ${themeDirective} Details: "${params.details}". ${coreDirectives(params)} The text must be described as a flat 2D graphic (decal, print) on a surface, while the characters and composition elements are photorealistic 3D. Create 7 prompts for these renderers: ${renderers.join(', ')}. For 'Hyperion Render', describe a prompt that combines the hyper-detailed organic sculpting of ZBrush for the composition elements with the photorealistic deferred rendering of Unreal Engine 5, mentioning the use of the Movie Render Queue. ${angleAndPositionRule} Background rule: ${backgroundRule}. Output Format: JSON with a "prompts" array of 7 strings.`;
            await executePromptGeneration(params, masterPrompt, renderers, 'MISTO (TEXTO 2D)');
        }

        filterButtonsContainer.addEventListener('click', (e) => {
            const clickedButton = e.target.closest('.filter-btn');
            if (clickedButton) {
                const targetKey = clickedButton.dataset.targetKey;

                document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                clickedButton.classList.add('active');

                let targetCard;
                document.querySelectorAll('.prompt-card').forEach(card => {
                    if (card.dataset.key === targetKey) {
                        card.classList.remove('hidden');
                        card.classList.add('flex');
                        targetCard = card;
                    } else {
                        card.classList.add('hidden');
                        card.classList.remove('flex');
                    }
                });

                if (targetCard) {
                    const textToCopy = targetCard.querySelector('.prompt-text').textContent;
                    copyToClipboard(textToCopy, clickedButton);
                }
            }
        });
        
        function setupRadioDeselection() {
            const radioGroups = ['angle-option', 'rotation-direction', 'background-option'];
            radioGroups.forEach(groupName => {
                let lastChecked = null;
                const radios = document.querySelectorAll(`input[name="${groupName}"]`);
                radios.forEach(radio => {
                    radio.addEventListener('click', function() {
                        if (this === lastChecked) {
                            this.checked = false;
                            lastChecked = null;
                        } else {
                            lastChecked = this;
                        }
                    });
                });
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
             displayHistory();
             setupRadioDeselection();
        });
    </script>
</body>
</html>
