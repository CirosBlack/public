<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Imagem com IA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
        }
        /* Spinner personalizado */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .placeholder-glow::placeholder {
            color: #9ca3af;
            opacity: 1;
        }
        .aspect-ratio-btn.active, .filter-btn.active, .style-btn.active {
            background-color: #4f46e5; /* bg-indigo-600 */
            color: white;
            font-weight: 600;
            border-color: #6366f1;
        }
        /* Fundo de xadrez para transparência */
        .checkerboard {
            background-color: #374151; /* bg-gray-700 */
            background-image:
                linear-gradient(45deg, #4b5563 25%, transparent 25%),
                linear-gradient(-45deg, #4b5563 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #4b5563 75%),
                linear-gradient(-45deg, transparent 75%, #4b5563 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .column-scroll::-webkit-scrollbar { width: 8px; }
        .column-scroll::-webkit-scrollbar-track { background: #1f2937; border-radius: 10px;}
        .column-scroll::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        .column-scroll::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .prompt-text-area {
            resize: vertical;
            min-height: 240px; /* Aumentado de 120px */
        }
        .prompt-text-area:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 1px #4f46e5;
        }

    </style>
</head>
<body class="text-white flex items-center justify-center min-h-screen p-4">

    <div class="w-full mx-auto bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 flex flex-col h-[95vh]">
        
        <!-- Cabeçalho -->
        <div class="text-center mb-8 flex-shrink-0">
            <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-indigo-500">Gerador de Imagem com IA</h1>
            <p class="text-gray-400 mt-2">Transforme sua ideia ou uma imagem de referência em arte.</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-10 gap-8 flex-grow min-h-0">
            <!-- Coluna 1: Controles -->
            <div id="controls-column" class="lg:col-span-3 flex flex-col space-y-6 overflow-y-auto column-scroll pr-2">
                <!-- PONTO DE PARTIDA -->
                <div class="space-y-4 p-4 bg-gray-900 rounded-lg">
                    <h3 class="font-bold text-lg text-gray-300">1. Ponto de Partida</h3>
                    <label for="idea-input" class="block font-medium text-gray-400">Opção A: Descreva sua ideia</label>
                    <textarea id="idea-input" rows="3" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition placeholder-glow" placeholder="Ex: um gato preto bocejando em uma almofada rosa"></textarea>
                    
                    <div class="space-y-2">
                        <label class="block font-medium text-gray-400 text-sm">Escolha um estilo:</label>
                        <div id="style-selector" class="grid grid-cols-3 gap-2">
                            <button class="style-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white py-2 px-2 rounded-lg transition text-sm active" data-style="realistic">Realista</button>
                            <button class="style-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white py-2 px-2 rounded-lg transition text-sm" data-style="illustration">Ilustração</button>
                            <button class="style-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white py-2 px-2 rounded-lg transition text-sm" data-style="cartoon">Cartoon</button>
                        </div>
                    </div>

                    <button id="generate-prompt-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105" data-mode="idea">Gerar Prompt com a Ideia</button>
                    <div class="relative flex py-3 items-center"><div class="flex-grow border-t border-gray-600"></div><span class="flex-shrink mx-4 text-gray-400">OU</span><div class="flex-grow border-t border-gray-600"></div></div>
                    <label class="block font-medium text-gray-400">Opção B: Envie uma imagem</label>
                    <div class="flex flex-col items-center gap-4">
                        <img id="image-preview" src="" class="w-full h-auto object-cover rounded-lg hidden bg-gray-700 border border-gray-600">
                        <div class="w-full flex gap-4">
                            <input type="file" id="image-upload-input" class="hidden" accept="image/*">
                            <label for="image-upload-input" class="w-full cursor-pointer bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition text-center block">Escolher Arquivo</label>
                            <button id="describe-image-btn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg transition disabled:bg-teal-400 disabled:cursor-not-allowed" disabled>Descrever Imagem</button>
                        </div>
                    </div>
                </div>
                 <!-- FUNDO -->
                <div class="space-y-3 p-4 bg-gray-900 rounded-lg">
                    <label class="block font-bold text-lg text-gray-300">2. Fundo (Opcional)</label>
                    <div id="background-selector" class="grid grid-cols-3 gap-2">
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white py-2 px-2 rounded-lg transition text-sm" data-bg="black">Preto</button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white py-2 px-2 rounded-lg transition text-sm" data-bg="white">Branco</button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white py-2 px-2 rounded-lg transition text-sm" data-bg="transparent">Transparente</button>
                    </div>
                </div>
                <!-- PROMPT FINAL -->
                <div class="space-y-3">
                    <label for="prompt-output" class="block font-medium text-gray-300">3. Prompt de alta qualidade</label>
                    <textarea id="prompt-output" rows="8" class="w-full bg-gray-900 border border-gray-600 rounded-lg p-3 text-gray-300" placeholder="O prompt detalhado aparecerá aqui..."></textarea>
                    <button id="copy-prompt-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105" disabled>Copiar Prompt</button>
                </div>
                <!-- DIMENSÃO -->
                <div class="space-y-4 p-4 bg-gray-900 rounded-lg">
                     <h3 class="font-bold text-lg text-gray-300">4. Dimensão</h3>
                     <div class="grid grid-cols-2 gap-x-8 gap-y-6">
                        <div>
                            <label class="block text-sm font-bold text-gray-300 mb-2 text-center">TEXTO</label>
                            <div class="flex space-x-4">
                                <label class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input name="text-dimension" type="radio" value="3d" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500" checked><span class="ml-3 text-sm">3D</span></label>
                                <label class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input name="text-dimension" type="radio" value="2d" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-3 text-sm">2D</span></label>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-bold text-gray-300 mb-2 text-center">COMPOSIÇÃO</label>
                            <div class="flex space-x-4">
                                <label class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input name="comp-dimension" type="radio" value="3d" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500" checked><span class="ml-3 text-sm">3D</span></label>
                                <label class="flex items-center p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 flex-1 justify-center"><input name="comp-dimension" type="radio" value="2d" class="h-4 w-4 bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"><span class="ml-3 text-sm">2D</span></label>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- FORMATO -->
                <div class="space-y-3 p-4 bg-gray-900 rounded-lg">
                    <h3 class="font-bold text-lg text-gray-300">5. Formato (Aspect Ratio)</h3>
                    <div id="aspect-ratio-selector" class="grid grid-cols-5 gap-2">
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition active" data-ratio="1:1">1:1</button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition" data-ratio="16:9">16:9</button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition" data-ratio="9:16">9:16</button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition" data-ratio="4:3">4:3</button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition" data-ratio="3:4">3:4</button>
                    </div>
                </div>
                <!-- PERSPECTIVA -->
                <div class="space-y-3 p-4 bg-gray-900 rounded-lg">
                    <h3 class="font-bold text-lg text-gray-300">6. Perspectiva</h3>
                    <div id="perspective-selector" class="grid grid-cols-2 gap-2">
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition active" data-perspective="frontal">Frontal</button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition" data-perspective="perspective">Perspectiva</button>
                    </div>
                    <div id="direction-selector" class="grid grid-cols-4 gap-2 mt-3 hidden">
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition flex justify-center items-center" data-direction="left" title="Vista da Direita">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/></svg>
                        </button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition flex justify-center items-center" data-direction="up" title="Vista de Baixo">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/></svg>
                        </button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition flex justify-center items-center" data-direction="down" title="Vista de Cima">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/></svg>
                        </button>
                        <button class="aspect-ratio-btn w-full bg-gray-700 border border-gray-600 hover:bg-gray-600 text-white font-bold py-2 px-2 rounded-lg transition flex justify-center items-center" data-direction="right" title="Vista da Esquerda">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/></svg>
                        </button>
                    </div>
                </div>
                <!-- AÇÃO PRINCIPAL -->
                 <div class="space-y-4 text-center sticky bottom-0 bg-gray-800 py-4">
                    <div class="flex items-center gap-4">
                        <button id="generate-image-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-purple-500">
                            Gerar Imagens
                        </button>
                        <button id="clear-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">
                            Limpar
                        </button>
                    </div>
                    <button id="generate-by-renderer-btn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 hidden">
                        Gerar Prompts por Renderizador
                    </button>
                </div>
            </div>

            <!-- Coluna 2: Renderizadores/Estilos -->
            <div id="styles-column" class="lg:col-span-3 bg-gray-900 rounded-lg p-4 flex flex-col overflow-y-auto column-scroll">
                <p id="styles-placeholder" class="text-gray-500 m-auto text-center">Os estilos e renderizadores aparecerão aqui...</p>
                 <div id="filter-buttons-wrapper" class="hidden w-full mb-4 flex-shrink-0">
                    <h3 id="filter-title" class="text-left text-md font-bold text-gray-300 mb-2">NAVEGAR POR ESTILO:</h3>
                    <div id="filter-buttons" class="flex flex-wrap justify-start gap-2"></div>
                </div>
                <div id="prompts-container" class="w-full space-y-4 flex-grow"></div>
            </div>

            <!-- Coluna 3: Imagens Geradas -->
            <div id="images-column" class="lg:col-span-4 bg-gray-900 rounded-lg flex items-center justify-center p-2 overflow-y-auto column-scroll">
                <div id="image-results-content" class="w-full h-full">
                    <div id="loader" class="loader hidden mx-auto my-auto"></div>
                    <p id="image-placeholder" class="text-gray-500 text-center my-auto">As imagens geradas aparecerão aqui</p>
                    <div id="image-grid" class="hidden w-full h-full grid grid-cols-2 gap-2">
                        <!-- Imagens geradas -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Área de Mensagens de Erro -->
        <div id="error-message" class="text-red-400 text-center font-medium min-h-[1.25rem] pt-4 flex-shrink-0"></div>

    </div>

    <!-- Modal de Refinamento -->
    <div id="refine-modal" class="fixed inset-0 bg-black/70 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-gray-800 rounded-lg p-6 w-full max-w-md space-y-4">
            <h3 class="text-xl font-bold">Refinar Imagem</h3>
            <p class="text-gray-400">Descreva as alterações que você deseja fazer na imagem.</p>
            <textarea id="refine-input" rows="3" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3" placeholder="Ex: adicione um céu estrelado, mude a cor para azul..."></textarea>
            <div class="flex justify-end gap-3">
                <button id="cancel-refine-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">Cancelar</button>
                <button id="confirm-refine-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Confirmar</button>
            </div>
        </div>
    </div>

    <!-- Visualização em Tela Cheia -->
    <div id="fullscreen-view" class="fixed inset-0 bg-black/90 flex items-center justify-center p-4 hidden z-50">
        <img id="fullscreen-image" src="" class="max-w-full max-h-full object-contain">
        <button id="close-fullscreen-btn" class="absolute top-4 right-4 text-white text-5xl font-bold opacity-80 hover:opacity-100">&times;</button>
        <button id="prev-fullscreen-btn" class="absolute left-4 top-1/2 -translate-y-1/2 text-white bg-gray-800/50 hover:bg-gray-800/80 p-2 rounded-full text-3xl transition">&lt;</button>
        <button id="next-fullscreen-btn" class="absolute right-4 top-1/2 -translate-y-1/2 text-white bg-gray-800/50 hover:bg-gray-800/80 p-2 rounded-full text-3xl transition">&gt;</button>
        <div class="absolute bottom-6 left-1/2 -translate-x-1/2 flex items-center gap-4">
            <button id="fullscreen-refine-btn" title="Refinar Imagem" class="bg-gray-800/80 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg flex items-center gap-2 transition">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="pointer-events-none" viewBox="0 0 16 16"><path d="M9.05.435c-.58-.58-1.52-.58-2.1 0L.436 6.95c-.58.58-.58-1.52 0 2.1l6.516 6.516c.58.58 1.52.58 2.1 0l6.516-6.516c.58-.58.58-1.52 0-2.1L9.05.435ZM7.293 4.293a1 1 0 0 1 1.414 0L10 5.586l1.293-1.293a1 1 0 1 1 1.414 1.414L11.414 7l1.293 1.293a1 1 0 0 1-1.414 1.414L10 8.414l-1.293 1.293a1 1 0 0 1-1.414-1.414L8.586 7 7.293 5.707a1 1 0 0 1 0-1.414Z"/></svg>
                Refinar
            </button>
            <a id="fullscreen-download-btn" href="#" download="imagem-ia.png" title="Download da Imagem" class="bg-gray-800/80 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg flex items-center gap-2 transition">
               <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="pointer-events-none" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
               Download
            </a>
        </div>
    </div>

    <script>
        // --- Seletores de Elementos ---
        const ideaInput = document.getElementById('idea-input');
        const styleSelector = document.getElementById('style-selector');
        const generatePromptBtn = document.getElementById('generate-prompt-btn');
        const promptOutput = document.getElementById('prompt-output');
        const copyPromptBtn = document.getElementById('copy-prompt-btn');
        const generateImageBtn = document.getElementById('generate-image-btn');
        const backgroundSelector = document.getElementById('background-selector');
        const aspectRatioSelector = document.getElementById('aspect-ratio-selector');
        const perspectiveSelector = document.getElementById('perspective-selector');
        const directionSelector = document.getElementById('direction-selector');
        const imageUploadInput = document.getElementById('image-upload-input');
        const imagePreview = document.getElementById('image-preview');
        const describeImageBtn = document.getElementById('describe-image-btn');
        const errorMessage = document.getElementById('error-message');
        const clearBtn = document.getElementById('clear-btn');

        // Coluna 2
        const stylesColumn = document.getElementById('styles-column');
        const stylesPlaceholder = document.getElementById('styles-placeholder');
        const filterButtonsWrapper = document.getElementById('filter-buttons-wrapper');
        const filterButtons = document.getElementById('filter-buttons');
        const promptsContainer = document.getElementById('prompts-container');
        
        // Coluna 3
        const imagesColumn = document.getElementById('images-column');
        const loader = document.getElementById('loader');
        const imagePlaceholder = document.getElementById('image-placeholder');
        const imageGrid = document.getElementById('image-grid');

        // Modal e Fullscreen
        const refineModal = document.getElementById('refine-modal');
        const refineInput = document.getElementById('refine-input');
        const cancelRefineBtn = document.getElementById('cancel-refine-btn');
        const confirmRefineBtn = document.getElementById('confirm-refine-btn');
        const fullscreenView = document.getElementById('fullscreen-view');
        const fullscreenImage = document.getElementById('fullscreen-image');
        const closeFullscreenBtn = document.getElementById('close-fullscreen-btn');
        const fullscreenRefineBtn = document.getElementById('fullscreen-refine-btn');
        const fullscreenDownloadBtn = document.getElementById('fullscreen-download-btn');
        const prevFullscreenBtn = document.getElementById('prev-fullscreen-btn');
        const nextFullscreenBtn = document.getElementById('next-fullscreen-btn');

        // --- Estado da Aplicação ---
        let selectedStyle = 'realistic';
        let selectedBackground = null;
        let selectedAspectRatio = '1:1';
        let selectedPerspective = 'frontal';
        let selectedDirection = null;
        let imageToRefine = null; 
        let fullscreenImageElements = [];
        let currentFullscreenIndex = 0;
        const API_KEY = ""; // Será fornecido pelo ambiente.

        // --- Funções de Lógica de UI ---

        clearBtn.addEventListener('click', () => {
            // Limpa campos de texto
            ideaInput.value = '';
            promptOutput.value = '';

            // Reseta a pré-visualização da imagem
            imagePreview.src = '';
            imagePreview.classList.add('hidden');
            imageUploadInput.value = ''; // Limpa a seleção do arquivo
            describeImageBtn.disabled = true;

            // Reseta botões de estado
            copyPromptBtn.disabled = true;
            generatePromptBtn.textContent = 'Gerar Prompt com a Ideia';
            generatePromptBtn.dataset.mode = 'idea';
            generateImageBtn.textContent = 'Gerar Imagens';
            document.getElementById('generate-by-renderer-btn').classList.add('hidden');


            // Limpa coluna de estilos
            promptsContainer.innerHTML = '';
            filterButtons.innerHTML = '';
            filterButtonsWrapper.classList.add('hidden');
            stylesPlaceholder.classList.remove('hidden');

            // Limpa coluna de imagens
            showImagesPlaceholder('As imagens geradas aparecerão aqui');

            // Reseta seletores
            styleSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            const defaultStyle = styleSelector.querySelector('button[data-style="realistic"]');
            if(defaultStyle) defaultStyle.classList.add('active');
            selectedStyle = 'realistic';

            backgroundSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            selectedBackground = null;
            
            aspectRatioSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            const defaultAspectRatio = aspectRatioSelector.querySelector('button[data-ratio="1:1"]');
            if(defaultAspectRatio) defaultAspectRatio.classList.add('active');
            selectedAspectRatio = '1:1';

            perspectiveSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            const defaultPerspective = perspectiveSelector.querySelector('button[data-perspective="frontal"]');
            if(defaultPerspective) defaultPerspective.classList.add('active');
            selectedPerspective = 'frontal';

            directionSelector.classList.add('hidden');
            directionSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            selectedDirection = null;

            // Reseta dimensões
            document.querySelector('input[name="text-dimension"][value="3d"]').checked = true;
            document.querySelector('input[name="comp-dimension"][value="3d"]').checked = true;

            // Limpa erros
            clearError();
        });

        styleSelector.addEventListener('click', (e) => {
            const target = e.target.closest('button');
            if (!target) return;
            styleSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            target.classList.add('active');
            selectedStyle = target.dataset.style;
        });

        backgroundSelector.addEventListener('click', (e) => {
            const target = e.target.closest('button');
            if (!target) return;
            const currentBg = target.dataset.bg;
            if (target.classList.contains('active')) {
                target.classList.remove('active');
                selectedBackground = null;
            } else {
                backgroundSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                target.classList.add('active');
                selectedBackground = currentBg;
            }
        });

        aspectRatioSelector.addEventListener('click', (e) => {
            const target = e.target.closest('button');
            if (!target) return;
            aspectRatioSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            target.classList.add('active');
            selectedAspectRatio = target.dataset.ratio;
        });

        perspectiveSelector.addEventListener('click', (e) => {
            const target = e.target.closest('button');
            if (!target) return;
            perspectiveSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            target.classList.add('active');
            selectedPerspective = target.dataset.perspective;

            if (selectedPerspective === 'perspective') {
                directionSelector.classList.remove('hidden');
            } else {
                directionSelector.classList.add('hidden');
                directionSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                selectedDirection = null;
            }
        });

        directionSelector.addEventListener('click', (e) => {
            const target = e.target.closest('button');
            if (!target) return;
            
            if (target.classList.contains('active')) {
                target.classList.remove('active');
                selectedDirection = null;
            } else {
                directionSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                target.classList.add('active');
                selectedDirection = target.dataset.direction;
            }
        });

        function setLoadingState(button, isLoading, loadingText) {
            button.disabled = isLoading;
            if (!button.dataset.originalText) button.dataset.originalText = button.textContent;
            button.textContent = isLoading ? loadingText : button.dataset.originalText;
        }
        
        function showError(message) { errorMessage.textContent = message; }
        function clearError() { errorMessage.textContent = ''; }

        // --- Funções da API ---

        async function fetchWithExponentialBackoff(url, options, maxRetries = 5, baseDelay = 1000) {
            let attempt = 0;
            while (attempt < maxRetries) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) return response.json();
                    if (response.status >= 400 && response.status < 600) {
                         const errorBody = await response.json();
                         throw new Error(`Erro na API: ${errorBody.error?.message || response.statusText}`);
                    }
                } catch (error) {
                    if (attempt === maxRetries - 1) throw error;
                    const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
                attempt++;
            }
            throw new Error("Falha na chamada da API após múltiplas tentativas.");
        }

        // --- Fluxo de Geração (Passos 1-3) ---

        imageUploadInput.addEventListener('change', () => {
            const file = imageUploadInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    imagePreview.src = e.target.result;
                    imagePreview.dataset.mimeType = file.type;
                    imagePreview.classList.remove('hidden');
                    describeImageBtn.disabled = false;
                    clearError();
                };
                reader.readAsDataURL(file);
            }
        });

        describeImageBtn.addEventListener('click', async () => {
            if (!imagePreview.src) return showError("Nenhuma imagem selecionada.");
            const base64Data = imagePreview.src.split(',')[1];
            const mimeType = imagePreview.dataset.mimeType;
            if (!base64Data || !mimeType) return showError("Não foi possível ler a imagem.");

            setLoadingState(describeImageBtn, true, 'Analisando...');
            clearError();
            promptOutput.value = "IA realizando análise técnica da imagem...";
            
            const coreVisionPrompt = `As a senior art director, perform an exhaustive analysis of the provided image to create a detailed creative brief. The output MUST be a valid JSON object with the key "details". "details": Provide an exhaustive, comma-separated list in ENGLISH describing every visual aspect for a master artist... (cover typography, composition, characters, elements, color, lighting, materials).`;
            let visionPrompt = "";

            switch (selectedStyle) {
                case 'illustration':
                    visionPrompt = `Analyze this image from the perspective of creating a beautiful, detailed illustration. Focus on line work, color palette, texture, and artistic style. ${coreVisionPrompt}`;
                    break;
                case 'cartoon':
                    visionPrompt = `Analyze this image to describe it as a stylized cartoon. Focus on exaggerated features, bold outlines, simplified shapes, and vibrant color schemes. ${coreVisionPrompt}`;
                    break;
                case 'realistic':
                default:
                    visionPrompt = `Analyze this image to describe it with extreme photorealism in mind. Focus on intricate details, realistic lighting, shadows, textures, and materials. ${coreVisionPrompt}`;
                    break;
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
            const payload = { contents: [{ parts: [ { text: visionPrompt }, { inlineData: { mimeType, data: base64Data } } ] }], generationConfig: { responseMimeType: "application/json" } };

            try {
                const result = await fetchWithExponentialBackoff(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (responseText) {
                    const descriptionJson = JSON.parse(responseText);
                    let finalDescription = descriptionJson.details || 'A IA não conseguiu extrair detalhes.';
                    
                    // Adiciona a informação do fundo, se selecionada
                    if (selectedBackground === 'black') {
                        finalDescription += ", on a solid black background";
                    } else if (selectedBackground === 'white') {
                        finalDescription += ", on a solid white background";
                    } else if (selectedBackground === 'transparent') {
                        finalDescription += ", with a transparent background";
                    }

                    promptOutput.value = finalDescription;
                    copyPromptBtn.disabled = false;
                    generatePromptBtn.textContent = 'Gerar Prompt com Descrição';
                    generatePromptBtn.dataset.mode = 'description';
                    document.getElementById('generate-by-renderer-btn').classList.remove('hidden');
                } else throw new Error("A resposta da IA estava vazia.");
            } catch (error) {
                console.error("Erro ao descrever imagem:", error);
                showError("Não foi possível analisar a imagem.");
                promptOutput.value = "";
            } finally {
                setLoadingState(describeImageBtn, false, 'Descrever Imagem');
            }
        });

        generatePromptBtn.addEventListener('click', async () => {
            const isDescriptionMode = generatePromptBtn.dataset.mode === 'description';
            const sourceText = isDescriptionMode ? promptOutput.value.trim() : ideaInput.value.trim();
            if (!sourceText) return showError(isDescriptionMode ? "Descrição vazia." : "Digite uma ideia.");

            setLoadingState(generatePromptBtn, true, 'Gerando...');
            clearError();
            promptOutput.value = "IA transformando em prompt profissional...";
            
            const quotedTextMatches = sourceText.match(/"([^"]*)"/g);
            let languageExceptionClause = "";
            if (quotedTextMatches && quotedTextMatches.length > 0) {
                const cleanMatches = quotedTextMatches.map(match => match.replace(/"/g, ''));
                languageExceptionClause = ` IMPORTANT RULE: The following specific Portuguese phrases MUST remain in Portuguese and must NOT be translated to English. Keep them exactly as they are: ${JSON.stringify(cleanMatches)}. Integrate them naturally into the final English prompt.`;
            }

            let systemPrompt = "";
            switch (selectedStyle) {
                case 'illustration':
                    systemPrompt = "You are an expert AI prompt engineer. Transform the following description into a detailed, high-quality, professional prompt for an image generation model. The final prompt MUST be in English, a concise, single paragraph, focusing on creating a beautiful and detailed illustration.";
                    break;
                case 'cartoon':
                    systemPrompt = "You are an expert AI prompt engineer. Transform the following description into a detailed, high-quality, professional prompt for an image generation model. The final prompt MUST be in English, a concise, single paragraph, designed to generate a fun, stylized cartoon image with expressive characters and vibrant colors.";
                    break;
                case 'realistic':
                default:
                    systemPrompt = "You are an expert AI prompt engineer. Transform the following description into a detailed, high-quality, professional prompt for an image generation model. The final prompt MUST be in English, a concise, single paragraph. Generate a breathtaking, photorealistic image highly similar to the one described. Output only the final English prompt.";
                    break;
            }
            
            systemPrompt += languageExceptionClause;

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
            const payload = { contents: [{ parts: [{ text: sourceText }] }], systemInstruction: { parts: [{ text: systemPrompt }] } };

            try {
                const result = await fetchWithExponentialBackoff(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (generatedText) {
                    promptOutput.value = generatedText.trim();
                    copyPromptBtn.disabled = false;
                    document.getElementById('generate-by-renderer-btn').classList.remove('hidden');
                } else throw new Error("A resposta da IA estava vazia.");
            } catch (error) {
                showError("Não foi possível gerar o prompt.");
                promptOutput.value = sourceText;
            } finally {
                const originalText = isDescriptionMode ? 'Gerar Prompt com Descrição' : 'Gerar Prompt com a Ideia';
                setLoadingState(generatePromptBtn, false, originalText);
            }
        });
        
        copyPromptBtn.addEventListener('click', () => copyToClipboard(promptOutput.value, copyPromptBtn));

        // --- Fluxo de Geração de Imagens (Botão Principal) ---
        generateImageBtn.addEventListener('click', async () => {
            const userPrompt = promptOutput.value.trim();
            if (!userPrompt) return showError("Crie um prompt primeiro.");

            setLoadingState(generateImageBtn, true, 'Gerando Imagens...');
            clearError();
            showImagesLoading();
            
            const finalPrompt = applyModifiersToPrompt(userPrompt);

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${API_KEY}`;
            const payload = { instances: [{ prompt: finalPrompt }], parameters: { sampleCount: 4, aspectRatio: selectedAspectRatio } };

            try {
                const result = await fetchWithExponentialBackoff(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (result.predictions && result.predictions.length > 0) {
                    displayImages(result.predictions);
                } else {
                    showImagesPlaceholder("Nenhuma imagem foi retornada.");
                    throw new Error("Nenhum dado de imagem recebido.");
                }
            } catch (error) {
                showImagesPlaceholder("Falha ao gerar imagens.");
                showError("Falha ao gerar as imagens. Tente novamente.");
            } finally {
                setLoadingState(generateImageBtn, false, 'Gerar 4 Imagens');
            }
        });

        document.getElementById('generate-by-renderer-btn').addEventListener('click', async () => {
            const userPrompt = promptOutput.value.trim();
            if (!userPrompt) return showError("Crie um prompt primeiro.");
            await generatePromptsByRenderer(userPrompt);
        });

        // --- Funções de Geração de Prompts por Estilo ---
        
        async function generatePromptsByRenderer(details) {
            const textDimension = document.querySelector('input[name="text-dimension"]:checked').value;
            const compDimension = document.querySelector('input[name="comp-dimension"]:checked').value;
            const params = { details, textDimension, compDimension };

            setLoadingState(generateImageBtn, true, 'Gerando Prompts...');
            clearError();
            stylesPlaceholder.classList.add('hidden');
            promptsContainer.innerHTML = '';
            filterButtons.innerHTML = '';
            filterButtonsWrapper.classList.add('hidden');
            showImagesPlaceholder("Selecione um estilo e gere as imagens.");
            
            if (textDimension === '3d' && compDimension === '3d') await generate3DPrompts(params);
            else if (textDimension === '2d' && compDimension === '2d') await generate2DPrompts(params);
            else if (textDimension === '3d' && compDimension === '2d') await generateMixed3DText2DCompPrompts(params);
            else await generateMixed2DText3DCompPrompts(params);

            setLoadingState(generateImageBtn, false, 'Gerar Prompts por Renderizador');
        }

        async function executePromptGeneration(params, masterPrompt, keys, type) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
            const payload = { contents: [{ parts: [{ text: masterPrompt }] }], generationConfig: { responseMimeType: "application/json" } };
            
            try {
                const result = await fetchWithExponentialBackoff(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const responseText = result.candidates[0].content.parts[0].text;
                const generatedPrompts = JSON.parse(responseText).prompts;
                if (generatedPrompts.length !== keys.length) throw new Error(`A IA não retornou ${keys.length} prompts.`);
                
                document.getElementById('filter-title').textContent = type.includes('3D') || type.includes('TEXTO 2D') ? 'NAVEGAR POR RENDERIZADOR:' : 'NAVEGAR POR ESTILO:';
                generatedPrompts.forEach((promptText, index) => {
                    const keyName = keys[index];
                    const card = document.createElement('div');
                    card.className = `prompt-card bg-gray-700 p-4 rounded-lg shadow-md flex-col ${index === 0 ? 'flex' : 'hidden'}`;
                    card.dataset.key = keyName;
                    // Corrige palavras juntas (ex: "ActionFigure" -> "Action Figure")
                    const processedPromptText = promptText.replace(/([a-z])([A-Z])/g, '$1 $2');
                    card.innerHTML = `
                        <h3 class="text-lg font-semibold text-indigo-400 mb-2">${keyName.toUpperCase()}</h3>
                        <textarea class="prompt-text-area w-full bg-gray-800 border border-gray-600 rounded-lg p-2 text-gray-300 flex-grow text-sm leading-relaxed" rows="12">${processedPromptText}</textarea>
                        <div class="flex gap-2 mt-3">
                            <button class="copy-specific-prompt-btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg text-sm">Copiar</button>
                            <button class="generate-style-images-btn flex-1 bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg text-sm">Gerar Imagens</button>
                        </div>
                    `;
                    promptsContainer.appendChild(card);
                    const filterButton = document.createElement('button');
                    filterButton.className = `filter-btn bg-gray-600 border border-gray-500 text-gray-200 text-xs font-semibold py-1 px-3 rounded-md hover:bg-indigo-500 transition-colors ${index === 0 ? 'active' : ''}`;
                    filterButton.textContent = keyName.toUpperCase();
                    filterButton.dataset.targetKey = keyName;
                    filterButtons.appendChild(filterButton);
                });
                filterButtonsWrapper.classList.remove('hidden');
                // Gera a imagem para o primeiro estilo automaticamente
                const firstCard = promptsContainer.querySelector('.prompt-card');
                if (firstCard) {
                     const promptText = firstCard.querySelector('.prompt-text-area').value;
                     const generateBtn = firstCard.querySelector('.generate-style-images-btn');
                     generateImagesForStyle(promptText, generateBtn);
                }
            } catch (error) {
                showError(`Erro ao gerar os prompts ${type}.`);
                stylesPlaceholder.classList.remove('hidden');
                console.error(`Erro em ${type}:`, error);
            }
        }

        const coreDirectives = (params) => `CORE DIRECTIVES: Must be a self-contained badge/emblem/logo. The "Additional Details" is the source of truth, FAITHFULLY translate this description. Adapt, do not invent new concepts. Ensure compound words are correctly spaced (e.g., "baile funk", not "bailefunk").`;
        
        async function generate2DPrompts(params) {
            const styles = ['Design PSD', 'Procreate', 'Watercolor', 'Anime/Manga', 'Vintage Cartoon', 'Sticker Style', 'Hearthstone', 'Arcane', 'Guilty Gear', 'Genshin Impact', 'Tower of Fantasy'];
            const masterPrompt = `Objective: Generate 11 distinct prompts for a 2D image AI to create a self-contained badge emblem logo. Details from user: "${params.details}". ${coreDirectives(params)} Create 11 prompts for these styles: ${styles.join(', ')}. Adapt the core concept to each style's conventions (e.g., for 'Procreate', describe a digital painting look with rich textures; for 'Sticker Style', describe a die-cut look with a thick white border; for 'Hearthstone', describe a highly detailed 2D cartoon-fantasy digital painting with vibrant, saturated colors, soft outlines, delicate shadows, and dramatic lighting, mimicking the polished, epic, and magical art style of the game Hearthstone; for 'Arcane', describe a detailed and cinematic 2D digital painting in the style of the series Arcane: League of Legends, featuring rich textures, visible brushstrokes, intense yet harmonious colors, and dramatic, cinematic lighting with strong contrasts, conveying emotion and intensity with stylized realism; for 'Guilty Gear', describe a stylized and dynamic 2D digital art piece that simulates 3D cell shading, in the style of Guilty Gear: STRIVE, with strong lines, vibrant colors, and marked anime-style shading, featuring a dramatic, high-energy pose, cinematic lighting, and exaggerated expressiveness; for 'Genshin Impact', describe a highly detailed fantasy anime-style illustration with soft, vibrant colors, delicate digital painting, atmospheric lighting, and fine lines, conveying a magical, poetic, and ethereal feel with ornate fantasy details and a polished look; for 'Tower of Fantasy', describe a highly detailed futuristic anime-style illustration with clean lines, vibrant and saturated colors, clear lighting, and smooth shading, mixing fantasy and technology with stylized outfits, tech armor, and a modern, polished sci-fi aesthetic). Output Format: JSON with a "prompts" array of 11 strings.`;
            await executePromptGeneration(params, masterPrompt, styles, '2D');
        }
        async function generate3DPrompts(params) {
            const renderers = ['V-Ray', 'Lumion', 'Twinmotion', 'Enscape', 'D5 Render', 'Unreal Engine 5', 'Hyperion Render', 'Cinematic Reality'];
            const masterPrompt = `Objective: Generate 8 professional prompts for 3D renderers to create a self-contained badge emblem logo. Details from user: "${params.details}". ${coreDirectives(params)} Create 8 prompts for these renderers: ${renderers.join(', ')}. For 'Hyperion Render', describe a prompt that combines the hyper-detailed organic sculpting of ZBrush with the photorealistic deferred rendering, global illumination, and advanced material properties (PBR, displacement) of Unreal Engine 5, mentioning the use of the Movie Render Queue for final output. For 'Cinematic Reality', describe a composite image where a photorealistic 3D render of ONLY the text is placed ON TOP OF a real, ultra-realistic photograph. The background MUST be explicitly described as a high-end DSLR photograph of the composition elements. The 3D text should be seamlessly integrated. Emphasize cinematic lighting, shallow depth of field that slightly blurs the photographic background, and professional color grading to make the text pop. The final result must look like a polished commercial advertisement. Output Format: JSON with a "prompts" array of 8 strings.`;
            await executePromptGeneration(params, masterPrompt, renderers, '3D');
        }
        async function generateMixed3DText2DCompPrompts(params) {
            const styles = ['Design PSD', 'Procreate', 'Watercolor', 'Anime/Manga', 'Vintage Cartoon', 'Sticker Style', 'Hearthstone', 'Arcane', 'Guilty Gear', 'Genshin Impact', 'Tower of Fantasy'];
            const masterPrompt = `Objective: Generate 11 prompts for a 2D image AI, creating a "trompe-l'oeil" effect self-contained badge emblem logo. Details from user: "${params.details}". ${coreDirectives(params)} The text must be described as a photorealistic 3D object, while the characters and composition elements must be 2D. Create 11 prompts for these 2D composition styles: ${styles.join(', ')}. Emphasize the 3D text vs 2D background contrast (e.g., for 'Hearthstone', describe a highly detailed 2D cartoon-fantasy digital painting with vibrant, saturated colors, soft outlines, delicate shadows, and dramatic lighting, mimicking the polished, epic, and magical art style of the game Hearthstone; for 'Arcane', describe a detailed and cinematic 2D digital painting in the style of the series Arcane: League of Legends, featuring rich textures, visible brushstrokes, intense yet harmonious colors, and dramatic, cinematic lighting with strong contrasts, conveying emotion and intensity with stylized realism; for 'Guilty Gear', describe a stylized and dynamic 2D digital art piece that simulates 3D cell shading, in the style of Guilty Gear: STRIVE, with strong lines, vibrant colors, and marked anime-style shading, featuring a dramatic, high-energy pose, cinematic lighting, and exaggerated expressiveness; for 'Genshin Impact', describe a highly detailed fantasy anime-style illustration with soft, vibrant colors, delicate digital painting, atmospheric lighting, and fine lines, conveying a magical, poetic, and ethereal feel with ornate fantasy details and a polished look; for 'Tower of Fantasy', describe a highly detailed futuristic anime-style illustration with clean lines, vibrant and saturated colors, clear lighting, and smooth shading, mixing fantasy and technology with stylized outfits, tech armor, and a modern, polished sci-fi aesthetic). Output Format: JSON with a "prompts" array of 11 strings.`;
            await executePromptGeneration(params, masterPrompt, styles, 'MISTO (TEXTO 3D)');
        }
        async function generateMixed2DText3DCompPrompts(params) {
            const renderers = ['V-Ray', 'Lumion', 'Twinmotion', 'Enscape', 'D5 Render', 'Unreal Engine 5', 'Hyperion Render', 'Cinematic Reality'];
            const masterPrompt = `Objective: Generate 8 prompts for 3D renderers to create a self-contained badge emblem logo. Details from user: "${params.details}". ${coreDirectives(params)} The text must be described as a flat 2D graphic (decal, print) on a surface, while the characters and composition elements are photorealistic 3D. Create 8 prompts for these renderers: ${renderers.join(', ')}. For 'Hyperion Render', describe a prompt that combines the hyper-detailed organic sculpting of ZBrush for the composition elements with the photorealistic deferred rendering of Unreal Engine 5, mentioning the use of the Movie Render Queue. For 'Cinematic Reality', describe an ultra-photorealistic prompt emulating a high-end DSLR camera shot with a prime lens for the 3D elements, emphasizing cinematic lighting, shallow depth of field, natural film grain, and professional color grading, ensuring the 2D text looks like a perfect, crisp decal on the realistic surface. Output Format: JSON with a "prompts" array of 8 strings.`;
            await executePromptGeneration(params, masterPrompt, renderers, 'MISTO (TEXTO 2D)');
        }
        
        // --- Interação com as Colunas 2 e 3 ---

        stylesColumn.addEventListener('click', async (e) => {
            const target = e.target;
            const filterButton = target.closest('.filter-btn');
            const copyButton = target.closest('.copy-specific-prompt-btn');
            const generateStyleButton = target.closest('.generate-style-images-btn');

            if (filterButton) {
                const targetKey = filterButton.dataset.targetKey;
                filterButtons.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                filterButton.classList.add('active');
                
                let activeCard;
                promptsContainer.querySelectorAll('.prompt-card').forEach(card => {
                    const isTarget = card.dataset.key === targetKey;
                    card.classList.toggle('hidden', !isTarget);
                    card.classList.toggle('flex', isTarget);
                    if(isTarget) activeCard = card;
                });

                // Gera imagem automaticamente ao selecionar o estilo
                if (activeCard) {
                    const promptText = activeCard.querySelector('.prompt-text-area').value;
                    const generateBtn = activeCard.querySelector('.generate-style-images-btn');
                    if (!generateBtn.disabled) {
                        await generateImagesForStyle(promptText, generateBtn);
                    }
                }
            }
            if (copyButton) {
                const card = copyButton.closest('.prompt-card');
                const textToCopy = card.querySelector('.prompt-text-area').value;
                copyToClipboard(textToCopy, copyButton);
            }
            if (generateStyleButton) {
                const card = generateStyleButton.closest('.prompt-card');
                const promptText = card.querySelector('.prompt-text-area').value;
                await generateImagesForStyle(promptText, generateStyleButton);
            }
        });

        async function generateImagesForStyle(promptText, button) {
            setLoadingState(button, true, 'Gerando...');
            showImagesLoading();
            const finalPrompt = applyModifiersToPrompt(promptText);
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${API_KEY}`;
            const payload = { instances: [{ prompt: finalPrompt }], parameters: { sampleCount: 4, aspectRatio: selectedAspectRatio } };
            try {
                const result = await fetchWithExponentialBackoff(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (result.predictions && result.predictions.length > 0) {
                    displayImages(result.predictions);
                } else {
                    showImagesPlaceholder("Nenhuma imagem foi retornada.");
                }
            } catch (error) {
                showImagesPlaceholder("Falha ao gerar imagens para este estilo.");
                console.error(error);
            } finally {
                setLoadingState(button, false, 'Gerar Imagens');
            }
        }

        // --- Funções de Exibição de Imagens e Interação ---

        function applyModifiersToPrompt(prompt) {
            let modifiedPrompt = prompt;

            // Perspectiva
            if (selectedPerspective === 'frontal') {
                modifiedPrompt = `orthographic front view, straight-on shot, centered, no perspective distortion, (${modifiedPrompt})`;
            } else if (selectedPerspective === 'perspective') {
                let perspectiveTerm = 'dynamic perspective view';
                if (selectedDirection === 'left') perspectiveTerm = 'view from the right, looking left';
                else if (selectedDirection === 'right') perspectiveTerm = 'view from the left, looking right';
                else if (selectedDirection === 'up') perspectiveTerm = 'view from below, looking up, low angle shot';
                else if (selectedDirection === 'down') perspectiveTerm = 'view from above, looking down, high angle shot';
                modifiedPrompt = `${perspectiveTerm}, rule of thirds, (${modifiedPrompt})`;
            }

            // Fundo
            if (selectedBackground === 'black') modifiedPrompt = `(${modifiedPrompt}) isolated on a solid, pure black background (#000000), clean, no gradients, no textures, studio lighting, no shadows on background.`;
            else if (selectedBackground === 'white') modifiedPrompt = `(${modifiedPrompt}) isolated on a solid, pure white background (#FFFFFF), clean, no gradients, no textures, studio lighting, no shadows on background.`;
            else if (selectedBackground === 'transparent') modifiedPrompt = `PNG image of (${modifiedPrompt}), professional cutout, 100% transparent background (full alpha channel), perfectly isolated, remove any background, no shadows, no ground plane.`;
            
            return modifiedPrompt;
        }

        function showImagesLoading() {
            imageGrid.classList.add('hidden');
            imagePlaceholder.classList.add('hidden');
            loader.classList.remove('hidden');
        }
        function showImagesPlaceholder(message) {
            imageGrid.classList.add('hidden');
            loader.classList.add('hidden');
            imagePlaceholder.textContent = message;
            imagePlaceholder.classList.remove('hidden');
        }
        function displayImages(predictions) {
            imageGrid.innerHTML = ''; 
            predictions.forEach(prediction => {
                const base64Data = prediction.bytesBase64Encoded;
                const imageUrl = `data:image/png;base64,${base64Data}`;
                const imageElement = createImageCard(imageUrl);
                imageGrid.appendChild(imageElement);
            });
            loader.classList.add('hidden');
            imagePlaceholder.classList.add('hidden');
            imageGrid.classList.remove('hidden');
        }

        function createImageCard(imageUrl) {
            const wrapper = document.createElement('div');
            const aspectRatios = {'1:1':'aspect-square','16:9':'aspect-[16/9]','9:16':'aspect-[9/16]','4:3':'aspect-[4/3]','3:4':'aspect-[3/4]'};
            let bgClass = selectedBackground === 'transparent' ? ' checkerboard' : '';
            const aspectRatioClass = aspectRatios[selectedAspectRatio] || 'aspect-square';
            wrapper.className = `relative group w-full h-full rounded-lg ${aspectRatioClass}${bgClass}`;
            wrapper.innerHTML = `
                <img src="${imageUrl}" alt="Imagem gerada" class="w-full h-full object-contain rounded-lg cursor-pointer" data-transparent="${selectedBackground === 'transparent'}">
                <div class="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-300 bg-black/50 rounded-lg p-2 flex justify-between items-end">
                    <button title="Refinar Imagem" class="refine-btn bg-gray-800/80 hover:bg-gray-700 text-white font-semibold py-1 px-2 rounded-lg flex items-center gap-1 text-xs transition">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="pointer-events-none" viewBox="0 0 16 16"><path d="M9.05.435c-.58-.58-1.52-.58-2.1 0L.436 6.95c-.58.58-.58-1.52 0 2.1l6.516 6.516c.58.58 1.52.58 2.1 0l6.516-6.516c.58-.58.58-1.52 0-2.1L9.05.435ZM7.293 4.293a1 1 0 0 1 1.414 0L10 5.586l1.293-1.293a1 1 0 1 1 1.414 1.414L11.414 7l1.293 1.293a1 1 0 0 1-1.414 1.414L10 8.414l-1.293 1.293a1 1 0 0 1-1.414-1.414L8.586 7 7.293 5.707a1 1 0 0 1 0-1.414Z"/></svg>
                        Refinar
                    </button>
                    <a href="${imageUrl}" download="imagem-ia.png" title="Download" class="download-btn bg-gray-800/80 hover:bg-gray-700 text-white font-semibold py-1 px-2 rounded-lg flex items-center gap-1 text-xs transition">
                       <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="pointer-events-none" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                       Download
                    </a>
                </div>
                <div class="absolute inset-0 bg-black/70 rounded-lg flex items-center justify-center hidden spinner-overlay"><div class="loader"></div></div>
            `;
            return wrapper;
        }
        
        imagesColumn.addEventListener('click', (e) => {
            const imageWrapper = e.target.closest('.relative.group');
            if (!imageWrapper) return;
            const imageElement = imageWrapper.querySelector('img');

            const refineBtn = e.target.closest('.refine-btn');
            const downloadBtn = e.target.closest('.download-btn');

            if (refineBtn) {
                // Se o botão de refinar foi clicado, abre o modal
                imageToRefine = imageElement;
                refineModal.classList.remove('hidden');
                refineInput.focus();
            } else if (!downloadBtn) { 
                // Se não foi o botão de download, trata como um clique para tela cheia
                fullscreenImageElements = Array.from(imageWrapper.closest('.grid').querySelectorAll('img'));
                currentFullscreenIndex = fullscreenImageElements.indexOf(imageElement);
                if (currentFullscreenIndex > -1) { // Garante que a imagem foi encontrada
                    updateFullscreenImage();
                    fullscreenView.classList.remove('hidden');
                }
            }
            // Se foi o botão de download, o comportamento padrão do link (<a>) fará o download
        });
        
        confirmRefineBtn.addEventListener('click', async () => {
            const refinementText = refineInput.value.trim();
            if (!refinementText || !imageToRefine) return showError("Por favor, descreva a alteração.");
            
            const currentImageBase64 = imageToRefine.src.split(',')[1];
            if (!currentImageBase64) return;

            refineModal.classList.add('hidden');
            const wrapper = imageToRefine.closest('.relative.group');
            const spinner = wrapper.querySelector('.spinner-overlay');
            spinner.classList.remove('hidden');

            let finalRefinementPrompt = `Apply this edit, described in Portuguese: "${refinementText}"`;
            const isTransparentRequest = refinementText.toLowerCase().match(/transparente|remover\s?o?\s?fundo|sem\s?fundo/);

            if (isTransparentRequest) finalRefinementPrompt = `Apply this edit: "${refinementText}". The final output MUST be a PNG with a 100% transparent background (full alpha channel). Perfectly isolate the subject and remove all background elements.`;
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${API_KEY}`;
            const payload = { contents: [{ role: "user", parts: [ { text: finalRefinementPrompt }, { inlineData: { mimeType: "image/png", data: currentImageBase64 } } ] }], generationConfig: { responseModalities: ['IMAGE'] } };

            try {
                const result = await fetchWithExponentialBackoff(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                if (base64Data) {
                    const newImageUrl = `data:image/png;base64,${base64Data}`;
                    imageToRefine.src = newImageUrl;
                    wrapper.querySelector('.download-btn').href = newImageUrl;
                    if (isTransparentRequest) {
                        imageToRefine.dataset.transparent = 'true';
                        wrapper.classList.add('checkerboard');
                    }
                } else throw new Error("Nenhum dado de imagem recebido no refinamento.");
            } catch (error) {
                console.error('Erro ao refinar a imagem:', error);
                showError("Falha ao refinar a imagem.");
            } finally {
                spinner.classList.add('hidden');
                refineInput.value = '';
                imageToRefine = null;
            }
        });
        
        // --- Lógica de Tela Cheia ---
        
        function updateFullscreenImage() {
            const currentImageElement = fullscreenImageElements[currentFullscreenIndex];
            fullscreenImage.src = currentImageElement.src;
            fullscreenDownloadBtn.href = currentImageElement.src;
            fullscreenView.classList.toggle('checkerboard', currentImageElement.dataset.transparent === 'true');
        }

        function navigateFullscreen(direction) {
            currentFullscreenIndex = (currentFullscreenIndex + direction + fullscreenImageElements.length) % fullscreenImageElements.length;
            updateFullscreenImage();
        }

        nextFullscreenBtn.addEventListener('click', () => navigateFullscreen(1));
        prevFullscreenBtn.addEventListener('click', () => navigateFullscreen(-1));
        fullscreenRefineBtn.addEventListener('click', () => {
            if (fullscreenImageElements[currentFullscreenIndex]) {
                imageToRefine = fullscreenImageElements[currentFullscreenIndex];
                fullscreenView.classList.add('hidden');
                refineModal.classList.remove('hidden');
            }
        });
        cancelRefineBtn.addEventListener('click', () => { refineModal.classList.add('hidden'); imageToRefine = null; });
        closeFullscreenBtn.addEventListener('click', () => { fullscreenView.classList.add('hidden'); fullscreenImageElements = []; });

        function copyToClipboard(text, buttonElement) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                if (document.execCommand('copy')) {
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = 'Copiado!';
                    setTimeout(() => { buttonElement.textContent = originalText; }, 2000);
                }
            } catch (err) { showError("Falha ao copiar."); }
            document.body.removeChild(textarea);
        }

    </script>
</body>
</html>

