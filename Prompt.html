<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Criador de Prompts Profissional (v54 - Ficha Técnica Interativa)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #F9FAFB; padding-bottom: 250px; }
        .step { display: none; }
        .step.active { display: block; }
        .option-card { background-color: #1F2937; border: 2px solid #374151; transition: all 0.2s ease-in-out; display: flex; flex-direction: column; justify-content: space-between; }
        .option-card:hover { border-color: #4f46e580; transform: translateY(-2px); }
        .option-card.selected { border-color: #4F46E5; background-color: #3730a3; }
        .color-swatch { width: 32px; height: 32px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: all 0.2s ease-in-out; }
        .color-swatch:hover, .color-swatch.selected { border-color: #F9FAFB; transform: scale(1.1); }
        .progress-bar-fill { transition: width 0.5s ease-in-out; }
        button:disabled { cursor: not-allowed; opacity: 0.7; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1F2937; }
        ::-webkit-scrollbar-thumb { background: #4F46E5; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #4338CA; }
        .toast-notification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: #10B981; color: white; padding: 12px 24px; border-radius: 8px; z-index: 100; opacity: 0; transition: opacity 0.5s, transform 0.5s; pointer-events: none; }
        .toast-notification.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        .toast-notification.error { background-color: #E53E3E; }
        #tech-sheet-bar { 
            position: fixed; 
            bottom: 0; 
            left: 0; 
            right: 0; 
            background-color: #1F2937;
            border-top: 1px solid #374151; 
            z-index: 50; 
            transition: transform 0.3s ease-in-out; 
            transform: translateY(100%); 
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.25);
        }
        #tech-sheet-bar.visible { transform: translateY(0); }
        #tech-sheet-content {
            max-height: 220px;
            overflow-y: auto;
            padding-right: 8px;
        }
        .tech-sheet-entry { 
            background-color: #374151;
            padding: 6px 12px; 
            border-radius: 9999px;
            font-size: 0.875rem; 
            white-space: nowrap; 
            display: inline-flex;
            align-items: center;
        }
        .tech-sheet-entry.clickable { cursor: pointer; transition: background-color 0.2s; }
        .tech-sheet-entry.clickable:hover { background-color: #4b5563; }
        .tech-sheet-entry.is-editing {
            width: 100%;
            white-space: normal;
        }
        #loadingOverlay {
            position: absolute;
            inset: 0;
            background-color: rgba(17, 24, 39, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 1rem; /* Corresponds to rounded-2xl */
            z-index: 20;
        }
        .example-tag {
            background-color: #374151;
            border: 1px solid #4B5563;
            color: #D1D5DB;
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .example-tag:hover {
            background-color: #4F46E5;
            color: #FFF;
            border-color: #4F46E5;
        }
        .clothing-details-section {
            background-color: #111827;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1rem;
            border: 1px solid #374151;
        }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8 max-w-4xl mx-auto">
            <h1 class="text-3xl md:text-4xl font-bold text-white mb-2">Criador de Prompts Profissional</h1>
            <p class="text-lg text-gray-400">Controle cada detalhe da sua criação com um fluxo inteligente.</p>
        </header>

        <!-- Main Content -->
        <div class="w-full">
            <!-- Progress Bar -->
            <div class="w-full bg-gray-700 rounded-full h-2.5 mb-8">
                <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full progress-bar-fill" style="width: 0%"></div>
            </div>

            <main id="prompt-builder" class="bg-gray-900 p-6 md:p-8 rounded-2xl shadow-2xl min-h-[500px] relative">
                 <div id="loadingOverlay" class="hidden">
                    <svg class="animate-spin h-10 w-10 text-white mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    <p id="loadingText" class="text-xl text-white">Processando...</p>
                </div>
                <!-- Steps will be dynamically generated here -->
            </main>
        </div>
    </div>

    <!-- Tech Sheet Bar -->
    <div id="tech-sheet-bar" class="p-4">
        <div class="container mx-auto flex flex-col sm:flex-row items-start gap-4">
            <div class="flex-grow w-full overflow-hidden">
                <div class="flex justify-between items-center mb-3 px-2">
                    <h2 class="text-lg font-semibold text-white">Ficha Técnica (Clique para editar)</h2>
                    <button onclick="toggleTechSheet()" class="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
                </div>
                <div id="tech-sheet-content" class="flex flex-wrap gap-2">
                    <!-- Dynamic content here -->
                </div>
            </div>
            <div class="flex-shrink-0 w-full sm:w-auto mt-4 sm:mt-0 space-y-2">
                <button id="regenerateButton" onclick="this.disabled=true; triggerFinalGeneration(true).finally(() => this.disabled=false)" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition-colors hidden items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" /></svg>
                    Gerar Novo Prompt
                </button>
                <button id="returnToPromptButton" onclick="cancelEditAndReturn()" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition-colors hidden items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.707 3.293a1 1 0 010 1.414L5.414 7H11a7 7 0 017 7v2a1 1 0 11-2 0v-2a5 5 0 00-5-5H5.414l2.293 2.293a1 1 0 11-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                    Voltar ao Prompt
                </button>
            </div>
        </div>
    </div>

    <div id="toast" class="toast-notification"></div>

    <script>
    // =================================================================================
    // DATA STORE: All steps, options, and logic are defined here.
    // =================================================================================
    const stepsData = {
        0: {
            title: "Como você quer começar?",
            type: 'start',
            autoPrompt: {
                title: "Prompt Automático Inteligente",
            }
        },
        1: {
            title: "Qual é a base da sua imagem?",
            type: 'category',
            key: 'baseCategory',
            options: [
                { label: "Fotorealista", description: "Crie imagens que parecem fotografias reais.", value: "photo", nextStep: 2 },
                { label: "Ilustração", description: "Crie arte com estilos visuais distintos.", value: "illustration", nextStep: 2 },
            ]
        },
        2: {
            title: "Escolha o Estilo Específico",
            type: 'ai-generated-choice',
            key: 'baseStyle',
            nextStep: 3,
            exampleTags: {
                photo: ["Cinematográfico", "Retrato em Estúdio", "Golden Hour", "Noir / P&B", "Fotografia de Rua"],
                illustration: ["Estilo Ghibli", "Anime Cyberpunk", "Fantasia Épica", "Comic Americano", "Aquarela"]
            },
            aiPrompt: (userInput, baseCategory) => `Você é um diretor de arte e engenheiro de prompt de IA extremamente criativo. Sua tarefa é gerar uma lista de estilos visuais inspiradores para um prompt de imagem, com base na entrada do usuário. Pense fora da caixa e evite clichês.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Cinematográfico"):** Interprete o texto como um tema e gere no mínimo 10 variações criativas e detalhadas sobre esse tema. Explore subgêneros, artistas famosos, técnicas específicas, etc.
2.  **Se a entrada for um número (ex: "7"):** Gere exatamente essa quantidade de estilos visuais diversos e interessantes, cobrindo uma ampla gama de possibilidades dentro da categoria de ${baseCategory}.
**Para cada estilo gerado, forneça um objeto JSON com:**
-   "label": O nome do estilo, em português.
-   "description": Uma descrição curta, evocativa e inspiradora em português.
-   "value": O termo técnico correspondente em inglês para o prompt.
**Retorne um array JSON de objetos.**`
        },
        3: {
            title: "Nome e Idade da Personagem",
            subtitle: "Comece dando um nome e uma idade para sua personagem. A idade é opcional.",
            type: 'text-input',
            inputs: [
                { id: 'characterName', placeholder: 'Digite o nome da personagem', key: 'name', type: 'text' },
                { id: 'characterAge', placeholder: 'Digite a idade (opcional)', key: 'age', type: 'number' }
            ],
            nextLogic: (data) => data.age ? 5 : 4
        },
        4: {
            title: "Faixa Etária",
            type: 'single-choice',
            key: 'age',
            nextStep: 5,
            options: [
                { label: "Garota (18-22 anos)", value: "a girl, approximately 18-22 years old" }, 
                { label: "Jovem Mulher (23-25 anos)", value: "a young woman, approximately 23-25 years old" },
                { label: "Mulher (26-34 anos)", value: "a woman, approximately 26-34 years old" }, 
                { label: "Mulher Madura (35+ anos)", value: "a mature woman, 35+ years old" },
            ]
        },
        5: {
            title: "Nacionalidades e Ascendências",
            type: 'ai-generated-choice',
            key: 'ethnicity',
            nextStep: 6,
            exampleTags: {
                all: ["Américas", "Europa", "Ásia", "África", "Oceania", "Fantasia"]
            },
            aiPrompt: (userInput) => `Você é um demógrafo criativo e world-builder. Sua tarefa é gerar uma lista de nacionalidades ou ascendências.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Europeu" ou "Asiático"):** Gere no mínimo 10 nacionalidades populares e interessantes daquela região.
2.  **Se a entrada for "Fantasia":** Gere no mínimo 10 ascendências de fantasia criativas (ex: "Elfo da Floresta Negra", "Humano com ascendência Dracônica", "Nascido do Fogo").
3.  **Se a entrada for um número (ex: "12"):** Gere essa quantidade de nacionalidades diversas de todo o mundo.
**Para cada item, forneça um objeto JSON com:**
-   "label": O nome em português (ex: "Brasileiro / Brasileira" ou "Elfo da Lua").
-   "description": Uma descrição curta e inspiradora.
-   "value": O termo correspondente em inglês (ex: "Brazilian" ou "Moon Elf").
**Adicione uma opção final:** \`{ "label": "Nenhum", "description": "Não especificar uma nacionalidade.", "value": "" }\`.
**Retorne um array JSON de objetos.**`
        },
        6: {
            title: "Biotipo Físico",
            type: 'ai-generated-choice',
            key: 'bodyType',
            nextStep: 7,
            exampleTags: { all: ["Magra", "Atlética", " curvilínea", "Gorda"] },
            aiPrompt: (userInput) => `Você é um diretor de casting e artista de personagens. Sua tarefa é gerar uma lista de biotipos físicos.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Atlética"):** Gere no mínimo 10 variações criativas desse biotipo (ex: "Corpo de dançarina", "Fisiculturista leve", "Corredora de longa distância").
2.  **Se a entrada for um número (ex: "8"):** Gere essa quantidade de biotipos diversos.
**Para cada item, forneça um objeto JSON com:**
-   "label": O nome em português.
-   "description": Uma breve descrição evocativa.
-   "value": O termo em inglês para o prompt.
**Adicione uma opção final:** \`{ "label": "Nenhum", "description": "Não especificar.", "value": "" }\`.
**Retorne um array JSON de objetos.**`
        },
        7: {
            title: "Cor da Pele",
            type: 'ai-generated-choice',
            key: 'skinColor',
            nextStep: 8,
            exampleTags: { all: ["Pele Clara", "Pele Pálida", "Pele Bronzeada", "Pele Oliva", "Pele Escura"] },
            aiPrompt: (userInput) => `Você é um especialista em dermatologia e artista de retratos. Sua tarefa é gerar uma lista de tons de pele.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Pele Escura"):** Gere no mínimo 10 variações poéticas e detalhadas (ex: "Pele cor de ébano", "Tom de chocolate amargo", "Pele de obsidiana polida").
2.  **Se a entrada for um número (ex: "10"):** Gere essa quantidade de tons de pele diversos.
**Para cada item, forneça um objeto JSON com:**
-   "label": O nome em português.
-   "description": Uma breve descrição poética.
-   "value": O termo em inglês para o prompt.
**Adicione uma opção final:** \`{ "label": "Nenhum", "description": "Não especificar.", "value": "" }\`.
**Retorne um array JSON de objetos.**`
        },
        8: {
            title: "Corte de Cabelo e Penteado",
            type: 'ai-generated-choice',
            key: 'hairStyle',
            nextStep: 9,
            exampleTags: { all: ["Longo", "Médio", "Curto", "Raspado", "Tranças"] },
            aiPrompt: (userInput) => `Você é um cabeleireiro de vanguarda e artista de personagens. Sua tarefa é gerar uma lista de penteados criativos e únicos.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Longo" ou "Tranças"):** Interprete como um tema e gere no mínimo 10 variações criativas. Pense em combinações, texturas, acessórios e estilos de diferentes culturas ou épocas.
2.  **Se a entrada for um número (ex: "12"):** Gere exatamente essa quantidade de penteados variados, explorando diferentes comprimentos e estilos.
**Para cada penteado, forneça um objeto JSON com:**
-   "label": O nome do penteado em português.
-   "description": Uma descrição curta e estilosa em português.
-   "value": O termo técnico correspondente em inglês para o prompt.
**Adicione uma opção final:** \`{ "label": "Nenhum", "description": "Não especificar o penteado.", "value": "" }\`.
**Retorne um array JSON de objetos.**`
        },
        9: {
            title: "Cor do Cabelo",
            type: 'single-choice',
            key: 'hairColor',
            nextStep: 10,
            manualInput: { id: 'hairColorManual', placeholder: 'Detalhes adicionais (ex: mechas azuis...)', key: 'hairColorDetails' },
            options: [
                { label: "Preto", value: "black hair" }, { label: "Loiro", value: "blonde hair" }, { label: "Castanho", value: "brown hair" },
                { label: "Ruivo", value: "red hair" }, { label: "Branco/Platinado", value: "white/platinum hair" }, { label: "Rosa", value: "pink hair" },
                { label: "Azul", value: "blue hair" }, { label: "Verde", value: "green hair" }, { label: "Nenhum", value: "" },
            ]
        },
        10: {
            title: "Cor dos Olhos",
            type: 'ai-generated-choice',
            key: 'eyeColor',
            nextStep: 11,
            exampleTags: { all: ["Azuis", "Verdes", "Castanhos", "Cor de Mel", "Pretos", "Fantasia"] },
            aiPrompt: (userInput) => `Você é um diretor de fotografia e artista de personagens. Sua tarefa é gerar variações de cor de olhos.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Azuis" ou "Fantasia"):** Gere no mínimo 10 variações criativas, incluindo detalhes como heterocromia, anéis limbares, brilho sobrenatural, padrões na íris, etc.
2.  **Se a entrada for um número (ex: "8"):** Gere essa quantidade de cores de olhos diversas, incluindo opções realistas e fantásticas.
**Para cada item, forneça um objeto JSON com:**
-   "label": O nome em português.
-   "description": Uma breve descrição evocativa.
-   "value": O termo em inglês para o prompt.
**Adicione uma opção final:** \`{ "label": "Nenhum", "description": "Não especificar.", "value": "" }\`.
**Retorne um array JSON de objetos.**`
        },
        11: {
            title: "Tamanho dos Seios",
            type: 'ai-generated-choice',
            key: 'breasts',
            nextStep: 12,
            exampleTags: { all: ["Pequenos", "Médios", "Grandes", "Volumosos"] },
            aiPrompt: (userInput) => `Você é um designer de personagens e anatomista. Sua tarefa é gerar variações para o tamanho dos seios de uma personagem.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Grandes"):** Gere no mínimo 10 variações criativas, descrevendo forma, volume e caimento de maneira respeitosa e artística (ex: "Seios fartos e redondos", "Busto proeminente e natural", "Seios em formato de gota").
2.  **Se a entrada for um número (ex: "6"):** Gere essa quantidade de variações de tamanho e forma.
**Para cada item, forneça um objeto JSON com:**
-   "label": O nome em português.
-   "description": Uma breve descrição anatômica e artística.
-   "value": O termo em inglês para o prompt.
**Adicione uma opção final:** \`{ "label": "Nenhum", "description": "Não especificar.", "value": "" }\`.
**Retorne um array JSON de objetos.**`
        },
        12: {
            title: "Composição da Cena",
            type: 'multi-choice-sections',
            nextStep: 13,
            sections: [
                {
                    title: "Orientação da Personagem",
                    key: 'characterView',
                    type: 'single-nav', // Custom type to trigger navigation
                    options: [
                        { label: "De Frente", value: "facing the camera" }, { label: "De Lado", value: "side view" }, { label: "De Costas", value: "from behind" },
                    ]
                },
            ]
        },
        13: {
            title: "Enquadramento e Composição",
            type: 'ai-generated-choice',
            isMulti: true,
            key: 'sceneComposition',
            nextStep: 14,
            exampleTags: { all: ["Corpo Inteiro", "Plano Médio", "Close-up no Rosto", "Ângulo Baixo", "Regra dos Terços"] },
            aiPrompt: (userInput) => `Você é um diretor de fotografia premiado. Sua tarefa é gerar opções de enquadramento e composição de cena.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Close-up"):** Gere no mínimo 10 variações criativas de close-ups e planos de detalhe (ex: "Close-up extremo nos olhos", "Plano detalhe das mãos", "Close-up com lente grande angular").
2.  **Se a entrada for um número (ex: "10"):** Gere essa quantidade de técnicas de composição e enquadramento diversas.
**Para cada item, forneça um objeto JSON com:**
-   "label": Nome em português.
-   "description": Breve descrição técnica/artística.
-   "value": Termo em inglês para o prompt.
**Retorne um array JSON de objetos.**`
        },
        14: {
            title: "Estilo da Personagem",
            type: 'ai-generated-choice',
            key: 'characterStyle',
            nextStep: 15,
            exampleTags: { all: ["Fantasia", "Sci-Fi", "Moderno", "Histórico", "Steampunk"] },
            aiPrompt: (userInput) => `Você é um figurinista e diretor de arte. Sua tarefa é gerar estilos de personagem.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Sci-Fi"):** Gere no mínimo 10 variações criativas de sub-estilos (ex: "Cyberpunk de rua", "Nobreza solar-punk", "Explorador de planetas retrô").
2.  **Se a entrada for um número (ex: "8"):** Gere essa quantidade de estilos diversos.
**Para cada item, forneça um objeto JSON com:**
-   "label": Nome em português.
-   "description": Breve descrição do conceito.
-   "value": Termo em inglês para o prompt.
**Adicione uma opção final:** \`{ "label": "Nenhum", "description": "", "value": "" }\`.
**Retorne um array JSON de objetos.**`
        },
        15: {
            title: "Maquiagem",
            type: 'ai-generated-choice',
            key: 'makeup',
            nextStep: 16,
            exampleTags: { all: ["Natural", "Olho Esfumado", "Glamour", "Gótica", "Artística"] },
            aiPrompt: (userInput) => `Você é um maquiador profissional de Hollywood. Sua tarefa é gerar estilos de maquiagem.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Artística"):** Gere no mínimo 10 variações criativas e ousadas (ex: "Maquiagem com respingos de tinta neon", "Delineado gráfico inspirado em caligrafia", "Sardas de folha de ouro").
2.  **Se a entrada for um número (ex: "10"):** Gere essa quantidade de estilos de maquiagem diversos.
**Para cada item, forneça um objeto JSON com:**
-   "label": Nome em português.
-   "description": Breve descrição do estilo.
-   "value": Termo em inglês para o prompt.
**Adicione uma opção final:** \`{ "label": "Nenhuma", "description": "", "value": "no makeup" }\`.
**Retorne um array JSON de objetos.**`
        },
        16: {
            title: "Acessórios",
            subtitle: "(Múltipla Escolha)",
            type: 'ai-generated-choice',
            isMulti: true,
            key: 'accessories',
            nextStep: 17,
            exampleTags: { all: ["Gótico", "Rockeira", "Patricinha", "Fantasia", "Sci-Fi"] },
            aiPrompt: (userInput) => `Você é um estilista de moda. Sua tarefa é gerar uma lista de acessórios.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Fantasia"):** Gere no mínimo 10 acessórios criativos e relevantes para o tema (ex: "Brincos de cristal lunar", "Gargantilha de vinhas espinhosas", "Anel com gema que pulsa luz").
2.  **Se a entrada for um número (ex: "15"):** Gere essa quantidade de acessórios diversos.
**Para cada item, forneça um objeto JSON com:**
-   "label": Nome em português.
-   "description": "".
-   "value": Termo em inglês para o prompt.
**Retorne um array JSON de objetos.**`
        },
        17: {
            title: "Expressão Facial",
            subtitle: "(Múltipla Escolha)",
            type: 'ai-generated-choice',
            isMulti: true,
            key: 'facialExpression',
            nextStep: 18,
            exampleTags: { all: ["Feliz", "Triste", "Irritada", "Sedutora", "Surpresa"] },
            aiPrompt: (userInput) => `Você é um diretor de atores e psicólogo. Sua tarefa é gerar expressões faciais complexas.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Feliz"):** Gere no mínimo 10 variações de felicidade com nuances (ex: "Sorriso melancólico", "Riso contido", "Alegria serena", "Euforia extasiada").
2.  **Se a entrada for um número (ex: "10"):** Gere essa quantidade de expressões diversas e com profundidade emocional.
**Para cada item, forneça um objeto JSON com:**
-   "label": Nome em português.
-   "description": Breve descrição da emoção por trás da expressão.
-   "value": Termo em inglês para o prompt.
**Retorne um array JSON de objetos.**`
        },
        18: {
            title: "Pose Corporal",
            subtitle: "(Múltipla Escolha)",
            type: 'ai-generated-choice',
            isMulti: true,
            key: 'bodyPose',
            nextStep: 19,
            exampleTags: { all: ["Poses Básicas", "Poses de Ação", "Poses Sensuais", "Poses Deitadas", "Poses Sentadas", "Poses de Pé"] },
            aiPrompt: (userInput) => `Você é um fotógrafo de moda e coreógrafo. Sua tarefa é gerar poses corporais dinâmicas e expressivas.
**Entrada do Usuário:** "${userInput}"
**Regras de Geração:**
1.  **Se a entrada for um texto (ex: "Poses de Ação"):** Gere no mínimo 10 variações de poses de ação criativas (ex: "No meio de um salto", "Aterrissando com impacto", "Desviando de um golpe", "Preparando um feitiço").
2.  **Se a entrada for um número (ex: "15"):** Gere essa quantidade de poses diversas.
**Para cada item, forneça um objeto JSON com:**
-   "label": Nome em português.
-   "description": Breve descrição do movimento ou da atitude.
-   "value": Termo em inglês para o prompt.
**Retorne um array JSON de objetos.**`
        },
        19: {
            title: "Vestimenta",
            type: 'clothing-builder',
            key: 'clothing',
            nextLogic: (data) => data.baseCategory.value === 'photo' ? 20 : 100,
            aiPrompt: (userInput) => `Você é um estilista de moda e figurinista de cinema. Analise a solicitação: "${userInput}".
**Regras de Geração:**
1. **Se a entrada for um texto (ex: "biquíni", "roupa íntima", "calcinha", "sutiã"):** Gere no mínimo 10 variações criativas e únicas. Pense em materiais, cortes, estilos (vintage, futurista, fantasia) e detalhes inesperados.
2. **Se a entrada for um número (ex: "8"):** Gere essa quantidade de peças de vestuário variadas (conjuntos, calcinhas, sutiãs).
**Para cada item, forneça um objeto JSON com:**
- "label": O nome criativo do item/conjunto.
- "description": Uma descrição evocativa do estilo e material.
- "value": O prompt em inglês para o item.
- "type": O tipo de item ("set", "panty", ou "bra").
**Retorne um array JSON de objetos.**`
        },
        20: {
            title: "Iluminação (Fotográfica)",
            key: 'lighting',
            type: 'single-choice',
            nextStep: 21,
            options: [
                { label: "Cinematográfica", value: "cinematic lighting", description: "A luz é usada para contar uma história, criar atmosfera e guiar o olhar com contraste, profundidade e cor." }, { label: "Luz Suave", value: "soft light", description: "Cria sombras suaves com transições graduais, ideal para retratos de beleza por ser lisonjeira." },
                { label: "Luz Dura", value: "hard light", description: "Produz sombras fortes e com bordas definidas, uma luz dramática que revela textura e cria alto contraste." }, { label: "Luz de Rembrandt", value: "Rembrandt lighting", description: "Padrão clássico que cria um pequeno triângulo de luz na bochecha sombreada, gerando um visual dramático." },
                { label: "Contraluz", value: "backlight", description: "A luz vem de trás do sujeito, usada para separá-lo do fundo com um contorno luminoso ou criar uma silhueta." }, { label: "Golden Hour", value: "golden hour lighting", description: "Luz naturalmente suave, quente e direcional do início da manhã ou final da tarde, criando uma atmosfera mágica." },
                { label: "Luz de Velas", value: "candlelight", description: "Fonte de luz quente, fraca e cintilante, que cria um ambiente íntimo, romântico ou misterioso com sombras profundas." }, { label: "Neon", value: "neon lighting", description: "Iluminação com cores vibrantes e saturadas de letreiros, criando uma atmosfera urbana, moderna ou cyberpunk." },
                { label: "Luz Subaquática", value: "underwater lighting", description: "Luz filtrada pela água, com dominante azul ou verde e padrões cáusticos, gerando uma atmosfera etérea." }, { label: "Luz de Recorte", value: "rim light, kicker", description: "Uma fina linha de luz no contorno do sujeito, essencial para separá-lo de um fundo escuro." },
                { label: "Silhueta", value: "silhouette", description: "Forma extrema de contraluz onde o sujeito aparece como uma forma preta sólida contra um fundo brilhante." }, { label: "Luz de Borboleta", value: "butterfly lighting", description: "Luz principal alta e frontal, criando uma pequena sombra sob o nariz. Look clássico e glamoroso." },
                { label: "Luz Dividida", value: "split lighting", description: "Ilumina exatamente metade do rosto, deixando a outra em sombra profunda para criar drama e tensão." }, { label: "High Key", value: "high key lighting", description: "Cena predominantemente clara e brilhante, com poucas sombras, transmitindo um visual otimista e limpo." },
                { label: "Low Key", value: "low key lighting", description: "Cena predominantemente escura, onde as sombras são o elemento principal para criar mistério e drama." }, { label: "Luz de Janela", value: "window light", description: "Uso de uma janela como fonte de luz principal, criando retratos com uma aparência natural e pictórica." },
            ]
        },
        21: {
            title: "Fundo / Local",
            type: 'single-choice',
            key: 'background',
            nextStep: 22,
            manualInput: { id: 'backgroundManual', placeholder: 'Ou escreva os detalhes aqui...', key: 'background' },
            options: [
                { label: "Estúdio", value: "in a studio with a plain gray background" }, { label: "Floresta Mística", value: "in a mystical forest" },
                { label: "Cidade Cyberpunk", value: "in a cyberpunk city" }, { label: "Quarto Aconchegante", value: "in a cozy room" },
                { label: "Praia Ensolarada", value: "on a sunny beach" }, { label: "Biblioteca Antiga", value: "in an old library" },
            ]
        },
        22: {
            title: "Ação da Personagem",
            type: 'multi-choice',
            key: 'action',
            isFinalStep: true,
            manualInput: { id: 'actionManual', placeholder: 'Ou escreva os detalhes aqui...', key: 'manualAction' },
            options: [
                { label: "Olhando para a câmera", value: "looking at the camera" }, { label: "Ajustando a roupa", value: "adjusting clothes" },
                { label: "Interagindo com o cenário", value: "interacting with the scenery" }, { label: "Em movimento", value: "in motion" },
            ]
        },
        23: { // Final prompt display step
            title: "Seu Prompt Profissional está Pronto!",
            subtitle: "Copie o prompt e use-o no seu gerador de imagens. Para máxima consistência, use o mesmo \"Código de Consistência\" em todas as imagens.",
            type: 'final-display',
        },
        100: {
            title: "Estilo de Iluminação (Artístico)",
            key: 'lighting',
            type: 'single-choice',
            nextStep: 101,
            options: [
                { label: "Luz Suave e Difusa", value: "soft, diffused lighting", description: "Ideal para retratos e cenas calmas, sem sombras fortes." },
                { label: "Contraste Alto (Chiaroscuro)", value: "high contrast, chiaroscuro lighting", description: "Usa sombras profundas e luz forte para criar drama e volume." },
                { label: "Contraluz (Rim Light)", value: "dramatic rim lighting, backlight", description: "Cria um contorno brilhante ao redor da personagem, separando-a do fundo." },
                { label: "Iluminação Mágica/Etérea", value: "magical, ethereal glow, god rays", description: "Luz que parece emanar da personagem ou de fontes místicas, com brilhos e raios." },
                { label: "Cores Vibrantes de Neon", value: "vibrant neon lighting", description: "Perfeito para temas cyberpunk ou cenas noturnas com uma atmosfera moderna." },
                { label: "Luz de Destaque (Spotlight)", value: "dramatic spotlight", description: "Foca um feixe de luz intenso na personagem, deixando o resto na escuridão." }
            ]
        },
        101: {
            title: "Tipo de Papel / Textura",
            key: 'paperTexture',
            type: 'single-choice',
            nextStep: 21,
            options: [] // Será preenchido dinamicamente
        }
    };

    const paperOptions = {
        'ghibli': { label: 'Papel Aquarela (Cold Press)', value: 'on cold press watercolor paper or textured gouache paper' }, 'anime-cyberpunk': { label: 'Papel Liso (Simulação Digital)', value: 'on a smooth digital illustration surface simulating hot press paper' },
        'fantasy-concept': { label: 'Papel Aquarela (Hot Press)', value: 'on hot press watercolor paper or acrylic painting paper' }, 'scifi-concept': { label: 'Papel para Marcadores (Marker Paper)', value: 'on smooth marker paper or Bristol board' },
        'watercolor': { label: 'Papel Aquarela 100% Algodão', value: 'on 100% cotton cold or hot press watercolor paper (300 g/m²)' }, 'pencil-sketch': { label: 'Papel de Esboço (Sketchbook)', value: 'on sketchbook paper with a slight texture' },
    };

    const clothingSizes = [
        { label: "Extra Pequeno (XS)", value: "extra small (XS) size" }, { label: "Pequeno (S)", value: "small (S) size" },
        { label: "Médio (M)", value: "medium (M) size" }, { label: "Largo (L)", value: "large (L) size" },
        { label: "Extra Largo (XL)", value: "extra large (XL) size" }
    ];

    const colors = [
        { name: 'Branco', hex: '#FFFFFF', value: 'white' }, { name: 'Preto', hex: '#000000', value: 'black' }, { name: 'Cinza', hex: '#808080', value: 'gray' },
        { name: 'Vermelho', hex: '#FF0000', value: 'red' }, { name: 'Laranja', hex: '#FFA500', value: 'orange' }, { name: 'Amarelo', hex: '#FFFF00', value: 'yellow' },
        { name: 'Verde', hex: '#008000', value: 'green' }, { name: 'Azul', hex: '#0000FF', value: 'blue' }, { name: 'Roxo', hex: '#800080', value: 'purple' },
        { name: 'Rosa', hex: '#FFC0CB', value: 'pink' }, { name: "Marrom", value: "brown", hex: "#A52A2A" }, { name: "Bege", value: "beige", hex: "#F5F5DC" },
        { name: 'Dourado', hex: '#FFD700', value: 'gold' }, { name: 'Prata', hex: '#C0C0C0', value: 'silver' }, { name: 'Ciano', hex: '#00FFFF', value: 'cyan' },
        { name: 'Magenta', hex: '#FF00FF', value: 'magenta' }, { name: 'Verde Limão', hex: '#32CD32', value: 'lime green' }, { name: 'Azul Marinho', hex: '#000080', value: 'navy blue' },
        { name: 'Verde-azulado', hex: '#008080', value: 'teal' }, { name: 'Bordô', hex: '#800000', value: 'maroon' }, { name: 'Oliva', hex: '#808000', value: 'olive' },
        { name: 'Coral', hex: '#FF7F50', value: 'coral' }, { name: 'Salmão', hex: '#FA8072', value: 'salmon' }, { name: 'Turquesa', hex: '#40E0D0', value: 'turquoise' },
        { name: 'Índigo', hex: '#4B0082', value: 'indigo' }, { name: 'Violeta', hex: '#EE82EE', value: 'violet' }, { name: 'Cáqui', hex: '#F0E68C', value: 'khaki' },
        { name: 'Ameixa', hex: '#DDA0DD', value: 'plum' }, { name: 'Orquídea', hex: '#DA70D6', value: 'orchid' }, { name: 'Carmesim', hex: '#DC143C', value: 'crimson' },
        { name: 'Azul Céu', hex: '#87CEEB', value: 'sky blue' }, { name: 'Verde-claro', hex: '#7FFF00', value: 'chartreuse' }, { name: 'Lavanda', hex: '#E6E6FA', value: 'lavender' },
        { name: 'Verde Menta', hex: '#98FF98', value: 'mint green' }
    ];

    // =================================================================================
    // APPLICATION STATE & DOM ELEMENTS
    // =================================================================================
    let promptData = {};
    let currentStep = 0;
    let isFinalPromptGenerated = false;
    let isEditingFromTechSheet = false;
    let aiGeneratedOptionsCache = {};
    let lastPositivePrompt = "";
    let lastNegativePrompt = "";
    let clothingStepState = {}; // State specific to the clothing builder step
    let promptDataBeforeEdit = null;
    
    const photoPath = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
    const illustrationPath = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 100, 101, 21, 22, 23];


    const mainContainer = document.getElementById('prompt-builder');
    const progressBar = document.getElementById('progressBar');
    const techSheetBar = document.getElementById('tech-sheet-bar');
    const techSheetContent = document.getElementById('tech-sheet-content');
    const regenerateButton = document.getElementById('regenerateButton');
    const returnToPromptButton = document.getElementById('returnToPromptButton');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');

    const sidebarLabels = {
        baseCategory: 'Base', baseStyle: 'Estilo', paperTexture: 'Textura', name: 'Nome', age: 'Idade',
        ethnicity: 'Etnia', bodyType: 'Biotipo', skinColor: 'Pele',
        hairStyle: 'Cabelo (Penteado)', hairColor: 'Cabelo (Cor)', hairColorDetails: 'Cabelo (Detalhes)', eyeColor: 'Olhos', breasts: 'Seios',
        makeup: 'Maquiagem', accessories: 'Acessórios', facialExpression: 'Expressão', bodyPose: 'Pose',
        clothing: 'Vestimenta',
        lighting: 'Iluminação', background: 'Fundo', action: 'Ação',
        characterView: 'Orientação', sceneComposition: 'Composição', manualPose: 'Pose Manual', manualAction: 'Ação Manual',
        ai_generated_input: 'Ideia Original'
    };
    
    // =================================================================================
    // API HELPER with KEY ROTATION and RETRY LOGIC
    // =================================================================================
    const apiKeys = [
        "AIzaSyAMc2t1NsMkkWS9nFNTrE5kijf-gWEKMuM", // Padrão
        "AIzaSyAEfzBCsoj9bj-V8d4wNou4XGFY-tAK51c", // Opção 2
        "AIzaSyANSX1GhESE_aKwcooAYrTkf3FXUDulKNI"  // Opção 3
    ];
    let currentApiKeyIndex = 0;
    
    async function fetchWithRetry(baseUrl, options, maxRetryRounds = 2) {
        for (let round = 0; round < maxRetryRounds; round++) {
            for (let i = 0; i < apiKeys.length; i++) {
                const apiKey = apiKeys[currentApiKeyIndex];
                const url = `${baseUrl}?key=${apiKey}`;

                try {
                    const response = await fetch(url, options);

                    if (response.status !== 429) {
                        return response; // Success or a non-rate-limit error
                    }
                    
                    // If 429, rotate key for the next attempt in this round
                    currentApiKeyIndex = (currentApiKeyIndex + 1) % apiKeys.length;

                } catch (error) {
                    // Handle network errors, etc.
                    if (i === apiKeys.length - 1 && round === maxRetryRounds - 1) {
                        throw error; // Re-throw last error if all retries fail
                    }
                    // Rotate key and continue
                    currentApiKeyIndex = (currentApiKeyIndex + 1) % apiKeys.length;
                }
            }
            // If all keys failed in a round, wait before starting the next round
            if (round < maxRetryRounds - 1) {
                const delay = Math.pow(2, round) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        throw new Error('API request failed after all retries with all keys.');
    }


    // =================================================================================
    // CORE LOGIC: Rendering, Navigation, Selection
    // =================================================================================

    function createOptionCard(option, stepData) {
        const card = document.createElement('div');
        card.className = 'option-card p-4 rounded-lg cursor-pointer';
        card.dataset.key = option.key || stepData.key;
        card.dataset.label = option.label;
        card.dataset.value = option.value;
        if (option.type) card.dataset.type = option.type;
        
        const isMulti = stepData.isMulti || (stepData.type || '').includes('multi');
        const isSingleNav = stepData.type === 'single-nav';

        if (isMulti) card.dataset.multi = 'true';
        if (isSingleNav) card.dataset.singleNav = 'true';

        let content = `<div class="card-content flex-grow">
            <h3 class="font-bold text-lg">${option.label}</h3>`;
        if (option.description && option.description.trim() !== "") {
            content += `<p class="text-sm text-gray-400 mt-1">${option.description}</p>`;
        }
        content += `</div>`;

        card.innerHTML = content;
        return card;
    }

    function renderStep(stepId) {
        const stepData = stepsData[stepId];
        if (!stepData) return;

        let stepHtml = `<div id="step-${stepId}" class="step">`;

        // Title and Subtitle
        stepHtml += `<h2 class="text-2xl font-semibold mb-2">${stepData.title}</h2>`;
        if (stepData.subtitle) {
            stepHtml += `<p class="text-gray-400 mb-6">${stepData.subtitle}</p>`;
        } else {
            stepHtml += `<div class="mb-6"></div>`;
        }
        
        const contentContainer = document.createElement('div');
        contentContainer.id = `step-content-${stepId}`;

        if (stepData.type === 'start') {
            contentContainer.innerHTML = `
                <div class="text-center">
                    <button class="w-full md:w-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-8 rounded-lg transition-colors text-lg" data-action="start-manual">Começar Manualmente</button>
                </div>
                <div class="my-8 border-t border-gray-700"></div>
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-center">${stepData.autoPrompt.title}</h3>
                    <p class="text-center text-gray-400 mb-6">Descreva sua ideia abaixo e a IA criará um prompt detalhado para você.</p>
                    <textarea id="autoPromptManual" class="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none" placeholder="Ex: ilustração de uma elfa loira na floresta, estilo ghibli..."></textarea>
                    <button class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition-colors mt-6" data-action="generate-auto">Gerar Prompt Inteligente</button>
                </div>
            `;
        } else if (stepData.type === 'final-display') {
             contentContainer.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-2 mb-2">
                    <button id="copyButton" data-action="copy" data-target="finalPrompt" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" /><path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" /></svg>
                        <span class="copy-text">Copiar Prompt</span>
                    </button>
                    <button id="addConsistencyButton" data-action="add-consistency" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" /></svg>
                        <span>Adicionar Consistência (IA)</span>
                    </button>
                    <button id="removeConsistencyButton" data-action="remove-consistency" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 000 2h6a1 1 0 100-2H7z" clip-rule="evenodd" /></svg>
                        <span>Remover Consistência</span>
                    </button>
                </div>
                <textarea id="finalPrompt" rows="8" class="w-full p-4 bg-gray-800 border border-gray-700 rounded-lg text-gray-300"></textarea>
                <h3 class="text-xl font-semibold mb-2 mt-6">Prompt Negativo</h3>
                <textarea id="negativePrompt" rows="4" class="w-full p-4 bg-gray-800 border border-gray-700 rounded-lg text-gray-300"></textarea>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mt-2">
                    <button data-action="copy" data-target="negativePrompt" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" /><path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" /></svg>
                        <span class="copy-text">Copiar Negativo</span>
                    </button>
                    <button data-action="regenerate-negative" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" /></svg>
                        <span>Gerar Novo Negativo</span>
                    </button>
                </div>
                <h3 class="text-xl font-semibold mb-2 mt-6">Código de Consistência (Seed)</h3>
                <div id="consistencySeed" class="w-full p-4 bg-gray-800 border border-gray-700 rounded-lg text-gray-300 font-mono"></div>
                <button data-action="copy" data-target="consistencySeed" class="w-full mt-2 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" /><path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" /></svg>
                    <span class="copy-text">Copiar Código</span>
                </button>
                <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-4">
                    <button id="toggleTechSheetButton" onclick="toggleTechSheet()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                        Ficha Técnica (Editar)
                    </button>
                    <button data-action="regenerate" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" /></svg>
                        Gerar Novo Prompt
                    </button>
                    <button data-action="restart" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" /></svg>
                        Começar de Novo
                    </button>
                </div>`;
        } else {
            // Navigation Buttons for regular steps
            const prevStep = getPreviousStep(stepId);
            const isFinal = stepData.isFinalStep;
             if (stepId > 0) {
                 stepHtml += `<div class="mb-8 flex justify-between w-full">
                    <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition-colors" data-action="prev" data-step="${prevStep}">Anterior</button>
                    <button id="nextButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-colors" data-action="next" ${stepData.type === 'clothing-builder' ? 'disabled' : ''}>${isFinal ? 'Gerar Prompt' : 'Próximo'}</button>
                </div>`;
             }

            if (stepData.type === 'clothing-builder') {
                contentContainer.innerHTML = `
                    <button class="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg transition-colors text-lg mb-6" data-action="select-nude">Totalmente Nua</button>
                    <div class="my-6 border-t border-gray-700"></div>
                    
                    <div id="clothing-selection-area">
                        <p class="text-gray-400 mb-4">Descreva o que deseja gerar (ex: "biquíni", "roupa íntima", "calcinha", "sutiã").</p>
                        <div class="flex gap-2 mb-4">
                            <input type="text" id="ai-input-${stepId}" class="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none" placeholder="Digite aqui...">
                            <button class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition-colors" data-action="generate-options" data-step-id="${stepId}">Gerar</button>
                        </div>
                        <div id="ai-options-container-${stepId}" class="grid grid-cols-2 md:grid-cols-3 gap-4 mt-6"></div>
                    </div>

                    <div id="clothing-details-area" class="hidden mt-6"></div>
                    
                    <div id="clothing-message-area" class="text-center text-amber-400 font-semibold p-4 mt-4 rounded-lg bg-amber-400/10 border border-amber-400/30 hidden"></div>

                    <div id="selected-clothing-display" class="mt-6 space-y-4"></div>
                `;
            } else if (stepData.type === 'ai-generated-choice') {
                const baseCategoryKey = promptData.baseCategory?.value || 'photo';
                const tags = stepData.exampleTags[baseCategoryKey] || stepData.exampleTags.all || [];
                const tagsHtml = tags.map(tag => `<button class="example-tag" data-action="use-tag" data-step-id="${stepId}">${tag}</button>`).join('');

                contentContainer.innerHTML = `
                    <div class="mb-4">
                        <p class="text-gray-400 mb-3">Sugestões (clique para usar):</p>
                        <div class="flex flex-wrap gap-2">${tagsHtml}</div>
                    </div>
                    <p class="text-gray-400 mb-4 mt-6">Ou gere novas opções. Digite um estilo (ex: Cinematográfico) para ver variações, ou um número (ex: 5) para obter estilos variados.</p>
                    <div class="flex gap-2 mb-4">
                        <input type="text" id="ai-input-${stepId}" class="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none" placeholder="Digite um estilo ou quantidade...">
                        <button class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition-colors" data-action="generate-options" data-step-id="${stepId}">Gerar Opções</button>
                    </div>
                    <div id="ai-options-container-${stepId}" class="grid grid-cols-2 md:grid-cols-3 gap-4 mt-6"></div>
                `;
                 if (aiGeneratedOptionsCache[stepId]) {
                    const container = contentContainer.querySelector(`#ai-options-container-${stepId}`);
                    aiGeneratedOptionsCache[stepId].forEach(opt => container.appendChild(createOptionCard(opt, { ...stepData })));
                }
            } else if (stepData.type === 'text-input') {
                const inputsHtml = stepData.inputs.map(input =>
                    `<input type="${input.type}" id="${input.id}" data-key="${input.key}" placeholder="${input.placeholder}" class="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none">`
                ).join('<div class="h-4"></div>');
                contentContainer.innerHTML = `<div class="space-y-4">${inputsHtml}</div>`;
            } else if (stepData.type.includes('choice') || stepData.type === 'category') {
                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-2 md:grid-cols-3 gap-4';
                if (stepId === 1) grid.className = 'grid grid-cols-1 md:grid-cols-2 gap-6';

                if (stepData.type === 'multi-choice-sections') {
                    grid.className = 'space-y-6';
                    stepData.sections.forEach(section => {
                        const sectionDiv = document.createElement('div');
                        sectionDiv.innerHTML = `<h3 class="text-xl font-semibold mb-4 text-indigo-400 border-b border-gray-700 pb-2">${section.title}</h3>`;
                        const sectionGrid = document.createElement('div');
                        sectionGrid.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4';
                        section.options.forEach(opt => {
                            sectionGrid.appendChild(createOptionCard(opt, { key: section.key, type: section.type }));
                        });
                        sectionDiv.appendChild(sectionGrid);
                        grid.appendChild(sectionDiv);
                    });
                } else if (stepId === 101) {
                    const styleKey = promptData.baseStyle?.value;
                    const options = styleKey && paperOptions[styleKey] ? [paperOptions[styleKey]] : [{ label: "Papel de Esboço", value: "on sketchbook paper" }];
                    options.push({ label: "Nenhum", value: "" });
                    options.forEach(opt => grid.appendChild(createOptionCard(opt, stepData)));
                } else {
                    stepData.options.forEach(opt => grid.appendChild(createOptionCard(opt, stepData)));
                }
                contentContainer.appendChild(grid);
            }

            if (stepData.manualInput) {
                const textarea = document.createElement('textarea');
                textarea.id = stepData.manualInput.id;
                textarea.placeholder = stepData.manualInput.placeholder;
                textarea.dataset.key = stepData.manualInput.key;
                textarea.className = "mt-4 w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none";
                contentContainer.appendChild(textarea);
            }
        }

        stepHtml += contentContainer.outerHTML;
        stepHtml += `</div>`;
        mainContainer.innerHTML = stepHtml;

        if(stepData.type === 'final-display' && isFinalPromptGenerated) {
            document.getElementById('finalPrompt').value = lastPositivePrompt;
            document.getElementById('negativePrompt').value = lastNegativePrompt;
        }

        if (stepData.type === 'clothing-builder') {
            updateClothingDisplay();
        } else {
            updateSelectionUI(stepId);
        }
    }

    function updateSelectionUI(stepId) {
        const stepContent = document.getElementById(`step-${stepId}`);
        if (!stepContent) return;

        stepContent.querySelectorAll('.option-card, .color-swatch').forEach(card => {
            const { key, value } = card.dataset;
            const data = promptData[key];
            let isSelected = false;

            if (Array.isArray(data)) {
                isSelected = data.some(item => item.value === value);
            } else if (data && data.value === value) {
                isSelected = true;
            }
            
            card.classList.toggle('selected', isSelected);
        });

        stepContent.querySelectorAll('input, textarea').forEach(input => {
            const { key } = input.dataset;
            if (promptData[key]) {
                input.value = promptData[key].label;
            }
        });
    }

    function showStep(stepId) {
        const activeStep = document.querySelector('.step.active');
        if (activeStep) activeStep.classList.remove('active');
        
        let stepToShow = document.getElementById(`step-${stepId}`);
        if (!stepToShow) {
            renderStep(stepId);
            stepToShow = document.getElementById(`step-${stepId}`);
        }
        
        if (stepToShow) {
            stepToShow.classList.add('active');
            currentStep = stepId;
            updateProgressBar();
        }
    }

    function goToStep(stepId) {
        if (stepId > 200 || stepId < 0) return; // Allow higher step numbers
        
        if (stepId < currentStep && !isEditingFromTechSheet) {
            // Do not clear cache when going back
        }

        showStep(stepId);
    }
    
    function getPreviousStep(stepId) {
        const currentPath = promptData.baseCategory?.value === 'illustration' ? illustrationPath : photoPath;
        const currentIndex = currentPath.indexOf(stepId);
        if (currentIndex > 0) {
            return currentPath[currentIndex - 1];
        }
        return 0;
    }

    function updateProgressBar() {
        const currentPath = promptData.baseCategory?.value === 'illustration' ? illustrationPath : photoPath;
        const total = currentPath.length - 2; // Exclude start (0) and end (23) steps
        const currentIndex = currentPath.indexOf(currentStep);

        if (currentIndex === -1) return;

        const progress = (currentIndex / total) * 100;
        progressBar.style.width = `${Math.min(progress, 100)}%`;
    }
    
    function handleNextAction() {
        isEditingFromTechSheet = false;
        const stepData = stepsData[currentStep];
        if (!stepData) return;
        
        if (stepData.isFinalStep) {
            triggerFinalGeneration();
            return;
        }

        document.querySelectorAll(`#step-${currentStep} input, #step-${currentStep} textarea`).forEach(input => {
            const { key } = input.dataset;
            const value = input.value.trim();
            if (value) {
                promptData[key] = { label: value, value: value };
                if (key === 'age') {
                    promptData.ageIsNumeric = true;
                    promptData.age.value = getAgeDescription(parseInt(value, 10));
                }
            } else {
                delete promptData[key];
                if (key === 'age') promptData.ageIsNumeric = false;
            }
        });
        
        updateTechSheet();

        let nextStep = (typeof stepData.nextLogic === 'function') ? stepData.nextLogic(promptData) : (stepData.nextStep || currentStep + 1);
        goToStep(nextStep);
    }
    
    function handleCardSelection(card) {
        const { key, label, value, multi, singleNav } = card.dataset;
        const stepData = stepsData[currentStep];

        if (multi === 'true') {
            if (!promptData[key]) promptData[key] = [];
            const index = promptData[key].findIndex(item => item.value === value);
            if (index > -1) {
                promptData[key].splice(index, 1);
            } else {
                promptData[key].push({ label, value });
            }
        } else { // Single choice
             const isAlreadySelected = card.classList.contains('selected');
             card.closest('.step').querySelectorAll(`[data-key="${key}"]`).forEach(c => c.classList.remove('selected'));

            if (!isAlreadySelected) {
                const option = findOption(key, value);
                promptData[key] = { label, value, description: option?.description || '' };
                card.classList.add('selected');
            } else {
                delete promptData[key];
            }
        }
        
        updateTechSheet();
        updateSelectionUI(currentStep);

        // Navigation Logic
        const shouldNavigate = !isEditingFromTechSheet && promptData[key];
        if (shouldNavigate && (singleNav === 'true' || (!multi && stepData.type !== 'clothing-builder'))) {
            setTimeout(handleNextAction, 250);
        }
    }

    function findOption(key, value) {
        for (const stepId in stepsData) {
            const step = stepsData[stepId];
            if (step.key === key && step.options) {
                return step.options.find(opt => opt.value === value);
            }
            if (step.true?.key === key && step.true.options) {
                 return step.true.options.find(opt => opt.value === value);
            }
             if (step.false?.key === key && step.false.options) {
                 return step.false.options.find(opt => opt.value === value);
            }
        }
        return null;
    }
    
    async function triggerFinalGeneration(closeTechSheet = false) {
        if (closeTechSheet) techSheetBar.classList.remove('visible');
        
        if (promptData.ai_generated_input?.value && Object.keys(promptData).length === 1) {
            await handleAutoGenerate(promptData.ai_generated_input.value);
        } else {
            const manualInputAction = document.getElementById('actionManual');
            if (manualInputAction) {
                const value = manualInputAction.value.trim();
                if (value) promptData.manualAction = { label: value, value: value };
                else delete promptData.manualAction;
            }
            updateTechSheet();
            await generateAndDisplayManualPrompt();
        }
    }

    // =================================================================================
    // CLOTHING BUILDER LOGIC (STEP 19)
    // =================================================================================

    function resetClothingStep() {
        clothingStepState = {
            currentSelection: null, // { label, value, type }
            panty: null,
            bra: null,
            set: null
        };
        promptData.clothing = {};
        if (document.getElementById('nextButton')) {
            document.getElementById('nextButton').disabled = true;
        }
    }

    function handleClothingSelection(card) {
        const { label, value, type } = card.dataset;
        clothingStepState.currentSelection = { label, value, type };
        
        document.getElementById('clothing-selection-area').classList.add('hidden');
        const detailsArea = document.getElementById('clothing-details-area');

        const sizeOptionsHtml = clothingSizes.map(size => 
            `<button class="option-card p-3" data-action="select-clothing-detail" data-type="size" data-label="${size.label}" data-value="${size.value}">${size.label}</button>`
        ).join('');

        const colorOptionsHtml = colors.map(color => 
            `<div class="color-swatch" style="background-color: ${color.hex};" title="${color.name}" data-action="select-clothing-detail" data-type="color" data-label="${color.name}" data-value="${color.value}"></div>`
        ).join('');

        detailsArea.innerHTML = `
            <div class="clothing-details-section">
                <h3 class="font-semibold text-lg mb-3">Tamanho:</h3>
                <div id="clothing-size-selector" class="grid grid-cols-3 gap-2">${sizeOptionsHtml}</div>
            </div>
            <div class="clothing-details-section">
                <h3 class="font-semibold text-lg mb-3">Cor:</h3>
                <div id="clothing-color-selector" class="grid grid-cols-6 md:grid-cols-9 gap-2">${colorOptionsHtml}</div>
            </div>
            <div class="clothing-details-section">
                <h3 class="font-semibold text-lg mb-3">Detalhes (Opcional):</h3>
                <textarea id="clothing-details-input" class="w-full p-2 bg-gray-800 border border-gray-700 rounded-lg" placeholder="Ex: renda, transparente, cetim..."></textarea>
            </div>
            <button class="w-full mt-6 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg" data-action="confirm-clothing-piece">Confirmar Peça</button>
        `;
        detailsArea.classList.remove('hidden');
    }

    function handleClothingDetailSelection(target) {
        const { type, value, label } = target.dataset;
        const selectorId = `#clothing-${type}-selector`;
        const container = document.querySelector(selectorId);

        // For single-choice like size
        if (type === 'size') {
            container.querySelectorAll('.option-card').forEach(c => c.classList.remove('selected'));
            target.classList.add('selected');
            clothingStepState.currentSelection.size = { label, value };
        }
        // For multi-choice like color
        if (type === 'color') {
            target.classList.toggle('selected');
            if (!clothingStepState.currentSelection.colors) clothingStepState.currentSelection.colors = [];
            
            const index = clothingStepState.currentSelection.colors.findIndex(c => c.value === value);
            if (index > -1) {
                clothingStepState.currentSelection.colors.splice(index, 1);
            } else {
                clothingStepState.currentSelection.colors.push({ label, value });
            }
        }
    }

    function confirmClothingPiece() {
        const selection = clothingStepState.currentSelection;
        if (!selection.size) {
            showToast("Por favor, selecione um tamanho.", 3000, true);
            return;
        }
        if (!selection.colors || selection.colors.length === 0) {
            showToast("Por favor, selecione pelo menos uma cor.", 3000, true);
            return;
        }
        selection.details = document.getElementById('clothing-details-input').value.trim();

        if (selection.type === 'set') {
            clothingStepState.set = { ...selection };
            clothingStepState.panty = null;
            clothingStepState.bra = null;
        } else if (selection.type === 'panty') {
            clothingStepState.panty = { ...selection };
            clothingStepState.set = null;
        } else if (selection.type === 'bra') {
            clothingStepState.bra = { ...selection };
            clothingStepState.set = null;
        }
        
        clothingStepState.currentSelection = null;
        document.getElementById('clothing-details-area').classList.add('hidden');
        document.getElementById('clothing-selection-area').classList.remove('hidden');
        document.getElementById(`ai-options-container-19`).innerHTML = '';
        
        updateClothingDisplay();
        checkClothingCompletion();
    }
    
    function updateClothingDisplay() {
        const displayArea = document.getElementById('selected-clothing-display');
        displayArea.innerHTML = '';
        
        const createDisplayCard = (item, type) => {
            const colors = item.colors.map(c => c.label).join(', ');
            return `
                <div class="bg-gray-800 p-4 rounded-lg border border-gray-700">
                    <h4 class="font-bold text-indigo-400 capitalize">${type}</h4>
                    <p class="text-lg">${item.label}</p>
                    <p class="text-sm text-gray-400">Tamanho: ${item.size.label}</p>
                    <p class="text-sm text-gray-400">Cor: ${colors}</p>
                    ${item.details ? `<p class="text-sm text-gray-400">Detalhes: ${item.details}</p>` : ''}
                </div>
            `;
        };

        if (clothingStepState.set) {
            displayArea.innerHTML = createDisplayCard(clothingStepState.set, 'Conjunto');
        } else {
            if (clothingStepState.panty) displayArea.innerHTML += createDisplayCard(clothingStepState.panty, 'Calcinha');
            if (clothingStepState.bra) displayArea.innerHTML += createDisplayCard(clothingStepState.bra, 'Sutiã');
        }
    }

    function checkClothingCompletion() {
        const messageArea = document.getElementById('clothing-message-area');
        const nextButton = document.getElementById('nextButton');
        messageArea.classList.add('hidden');
        
        if (clothingStepState.set) {
            nextButton.disabled = false;
        } else if (clothingStepState.panty && clothingStepState.bra) {
            nextButton.disabled = false;
        } else if (clothingStepState.panty) {
            messageArea.textContent = "Ótimo! Agora gere e escolha um sutiã para combinar.";
            messageArea.classList.remove('hidden');
            nextButton.disabled = true;
        } else if (clothingStepState.bra) {
            messageArea.textContent = "Ótimo! Agora gere e escolha uma calcinha para combinar.";
            messageArea.classList.remove('hidden');
            nextButton.disabled = true;
        } else {
            nextButton.disabled = true;
        }
        
        // Finalize data for prompt generation
        promptData.clothing = { ...clothingStepState };
        updateTechSheet();
    }


    // =================================================================================
    // EVENT LISTENERS & INITIALIZATION
    // =================================================================================
    mainContainer.addEventListener('click', (e) => {
        const card = e.target.closest('.option-card');
        const actionTarget = e.target.closest('[data-action]');

        if (actionTarget) {
            const { action, step, target: dataTarget, stepId } = actionTarget.dataset;
            switch(action) {
                case 'prev':
                    isEditingFromTechSheet = false;
                    goToStep(parseInt(step, 10));
                    break;
                case 'next':
                    handleNextAction();
                    break;
                case 'restart':
                    restart();
                    break;
                case 'start-manual':
                    goToStep(1);
                    break;
                case 'generate-auto':
                    handleAutoGenerate();
                    break;
                case 'generate-options':
                    generateOptionsWithAI(parseInt(stepId, 10));
                    break;
                case 'use-tag':
                    document.getElementById(`ai-input-${stepId}`).value = actionTarget.textContent;
                    generateOptionsWithAI(parseInt(stepId, 10));
                    break;
                case 'copy':
                    copyToClipboard(dataTarget, actionTarget.querySelector('.copy-text'));
                    break;
                case 'add-consistency':
                    addConsistencyText();
                    break;
                case 'remove-consistency':
                    removeConsistencyText();
                    break;
                case 'regenerate-negative':
                    handleRegenerateNegative();
                    break;
                case 'select-nude':
                    promptData.clothing = { nude: { label: 'Totalmente Nua', value: 'completely nude' }};
                    handleNextAction();
                    break;
                case 'select-clothing-item':
                    handleClothingSelection(actionTarget);
                    break;
                case 'select-clothing-detail':
                    handleClothingDetailSelection(actionTarget);
                    break;
                case 'confirm-clothing-piece':
                    confirmClothingPiece();
                    break;
                case 'regenerate':
                    triggerFinalGeneration(false);
                    break;
            }
        } else if (card) {
            handleCardSelection(card);
        }
    });

    techSheetContent.addEventListener('click', (e) => {
        const entry = e.target.closest('.tech-sheet-entry');
        if (!entry) return;

        const actionTarget = e.target.closest('[data-action]');

        if (actionTarget) {
            const { action } = actionTarget.dataset;
            if (action === 'save-edited-prompt') {
                const key = entry.dataset.key;
                const input = entry.querySelector('input');
                const newText = input.value.trim();
                
                if (newText) {
                    promptData[key] = { label: newText, value: newText };
                    showToast("Ideia original atualizada. Clique em 'Gerar Novo Prompt'.");
                } else {
                    delete promptData[key];
                    showToast("Item removido.");
                }
                updateTechSheet();
                return;
            }
            
            if (action === 'cancel-edit-prompt') {
                updateTechSheet();
                return;
            }
        }

        if (entry.dataset.step) {
            handleTechSheetClick(parseInt(entry.dataset.step, 10));
        } else if (entry.classList.contains('clickable')) {
            makeTechSheetEntryEditable(entry);
        }
    });

    function makeTechSheetEntryEditable(entry) {
        if (techSheetContent.querySelector('input')) {
            showToast("Salve ou cancele a edição atual primeiro.", 3000, true);
            return;
        }

        const key = entry.dataset.key;
        const data = promptData[key];
        if (!data) return;

        const currentValueText = data.label || '';

        entry.classList.remove('clickable');
        entry.classList.add('is-editing'); // Add class for styling

        entry.innerHTML = `
            <div class="flex items-center gap-2 w-full">
                <span class="font-semibold text-indigo-400">${sidebarLabels[key]}:</span>
                <input type="text" value="${currentValueText.replace(/"/g, '&quot;')}" class="flex-grow bg-gray-700 text-white p-1 rounded outline-none focus:ring-2 focus:ring-indigo-500">
                <button data-action="save-edited-prompt" class="bg-green-600 hover:bg-green-700 p-1 rounded-full flex-shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-white" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                </button>
                <button data-action="cancel-edit-prompt" class="bg-red-600 hover:bg-red-700 p-1 rounded-full flex-shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-white" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.697a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                </button>
            </div>
        `;
        entry.querySelector('input').focus();
    }
    
    function getAgeDescription(age) {
        if (age >= 46) return `a mature woman, approximately ${age} years old`;
        if (age >= 31) return `a woman, approximately ${age} years old`;
        if (age >= 23) return `a young woman, approximately ${age} years old`;
        if (age >= 18) return `a girl, approximately ${age} years old`;
        return `${age} years old`;
    }
    
    function showToast(message, duration = 3000, isError = false) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.className = 'toast-notification';
        if (isError) toast.classList.add('error');
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), duration);
    }
    
    function copyToClipboard(elementId, textElement) {
        const element = document.getElementById(elementId);
        const textToCopy = element.tagName === 'TEXTAREA' ? element.value : element.innerText;
        const originalText = textElement.textContent;

        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        textArea.style.position = 'fixed';
        textArea.style.top = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();

        try {
            document.execCommand('copy');
            textElement.textContent = 'Copiado!';
            showToast('Copiado para a área de transferência!');
        } catch (err) {
            textElement.textContent = 'Falha ao copiar';
            showToast('Falha ao copiar.', 3000, true);
        }

        document.body.removeChild(textArea);
        setTimeout(() => { textElement.textContent = originalText; }, 2000);
    }
    
    function restart() {
        promptData = {};
        aiGeneratedOptionsCache = {};
        isFinalPromptGenerated = false;
        isEditingFromTechSheet = false;
        resetClothingStep();
        techSheetBar.classList.remove('visible');
        updateTechSheet();
        goToStep(0);
    }

    function toggleTechSheet() {
        const techSheetBar = document.getElementById('tech-sheet-bar');
        techSheetBar.classList.toggle('visible');
        if (techSheetBar.classList.contains('visible')) {
            updateTechSheet();
        }
    }

    function handleTechSheetClick(stepId) {
        promptDataBeforeEdit = JSON.parse(JSON.stringify(promptData));
        isEditingFromTechSheet = true;
        goToStep(stepId);
    }
    
    function cancelEditAndReturn() {
        if (promptDataBeforeEdit) {
            promptData = JSON.parse(JSON.stringify(promptDataBeforeEdit));
            promptDataBeforeEdit = null; // Clear the backup
        }
        isEditingFromTechSheet = false;
        updateTechSheet(); // Update the sheet with restored data
        goToStep(23); // Go to final prompt display
        toggleTechSheet(); // Close the sheet
    }
    
    // =================================================================================
    // PROMPT GENERATION LOGIC
    // =================================================================================
    
    function summarizeChoices(data) {
        const summaryParts = [];
        const displayOrder = Object.keys(sidebarLabels);

        const formatClothing = (clothingData) => {
            if (clothingData.nude) return "Vestimenta: Totalmente Nua";
            if (clothingData.set) {
                const { label, size, colors, details, description } = clothingData.set;
                const colorStr = colors.map(c => c.label).join(', ');
                return `Vestimenta: Conjunto ${label} (Descrição: ${description}), Tamanho ${size.label}, Cor ${colorStr}${details ? `, Detalhes: ${details}` : ''}`;
            }
            let pieceSummary = [];
            if (clothingData.panty) {
                const { label, size, colors, details, description } = clothingData.panty;
                const colorStr = colors.map(c => c.label).join(', ');
                pieceSummary.push(`Calcinha ${label} (Descrição: ${description}), Tamanho ${size.label}, Cor ${colorStr}${details ? `, Detalhes: ${details}` : ''}`);
            }
            if (clothingData.bra) {
                const { label, size, colors, details, description } = clothingData.bra;
                const colorStr = colors.map(c => c.label).join(', ');
                pieceSummary.push(`Sutiã ${label} (Descrição: ${description}), Tamanho ${size.label}, Cor ${colorStr}${details ? `, Detalhes: ${details}` : ''}`);
            }
            return `Vestimenta: ${pieceSummary.join(' e ')}`;
        };

        displayOrder.forEach(key => {
            const item = data[key];
            if (!item) return;

            if (key === 'clothing') {
                const clothingSummary = formatClothing(item);
                if(clothingSummary) summaryParts.push(clothingSummary);
                return;
            }
            
            if (key === 'age' && item.value) {
                summaryParts.push(`Idade: ${item.value}`); // Use the direct English value for clarity
                return; 
            }

            const label = sidebarLabels[key] || key;
            let valueText = '';
            if (Array.isArray(item)) {
                valueText = item.map(i => `${i.label}${i.description ? ` (Descrição: ${i.description})` : ''}`).join(', ');
            } else if (item.label) {
                valueText = `${item.label}${item.description ? ` (Descrição: ${item.description})` : ''}`;
            }

            if (valueText) {
                summaryParts.push(`${label}: ${valueText}`);
            }
        });

        return summaryParts.join('\n');
    }

    async function generateManualPromptWithAPI(choicesSummary) {
        loadingOverlay.classList.remove('hidden');
        loadingText.textContent = "Gerando prompt otimizado com IA...";

        const systemPrompt = `Você é um engenheiro de prompt de IA e diretor de arte de classe mundial, com a tarefa de criar o prompt de imagem perfeito. Você receberá uma ficha técnica com as escolhas do usuário. Sua missão é usar esta ficha como base para **expandir e elaborar** uma cena visualmente rica, cinematográfica e hiperdetalhada em INGLÊS.

**INSTRUÇÕES CRÍTICAS E OBRIGATÓRIAS:**
1.  **EXPANDA, NÃO APENAS LISTE:** As escolhas do usuário são o esqueleto. Sua função é adicionar os músculos, a pele e a alma. Elabore os detalhes, adicione elementos sensoriais (texturas, sons, temperaturas) e crie uma atmosfera envolvente. Use as descrições fornecidas para adicionar profundidade.
2.  **CRIE UMA NARRATIVA VISUAL:** Não liste as características. Construa uma cena coesa que conte uma pequena história. Descreva a personagem, o que ela está a fazer, a sua expressão, e como ela interage com o ambiente de forma cinematográfica. Pinte um quadro com palavras.
3.  **SEJA HIPERDETALHADO:** Adicione detalhes técnicos e artísticos. Fale sobre a textura dos tecidos, o brilho nos olhos, a qualidade da luz (ex: 'luz dourada do final da tarde a filtrar-se pelas árvores'), o tipo de lente da câmara (mesmo que seja uma ilustração). O objetivo é um prompt rico que não deixa espaço para ambiguidades.
4.  **FORMATO:** O prompt final deve ser um único parágrafo em INGLÊS, sem asteriscos (\`*\`) ou qualquer outra formatação markdown.
5.  **ATENÇÃO À IDADE:** Preste atenção estrita à descrição da idade. Se a entrada for 'a girl', use o termo 'girl'. Se for 'a young woman', use 'young woman'. Não confunda essas faixas etárias distintas.

Abaixo está a ficha técnica do usuário:
---
${choicesSummary}
---

Agora, com base nesta ficha, crie o prompt positivo perfeito, seguindo TODAS as regras acima.`;

        const payload = { contents: [{ role: "user", parts: [{ text: systemPrompt }] }] };

        try {
            const baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent`;
            const response = await fetchWithRetry(baseUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const result = await response.json();
            const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) throw new Error("Resposta da API vazia para o prompt positivo.");
            return text.trim().replace(/\*/g, ''); // Remove any lingering asterisks just in case
        } catch (error) {
            console.error("Falha ao gerar prompt positivo com API:", error);
            showToast("Falha ao gerar o prompt otimizado com IA. Tente novamente.", 4000, true);
            return null;
        }
    }
    
    async function generateConsistencyWithAPI(positivePrompt) {
        loadingOverlay.classList.remove('hidden');
        loadingText.textContent = "Analisando consistência...";
        
        const systemPrompt = `Analyze the following prompt and extract key, consistent character descriptors. Return them as a simple comma-separated list in English. Focus on core, reusable traits like name, age, ethnicity, hair color/style, eye color, and body type.
        Positive Prompt: "${positivePrompt}"
        Respond with ONLY the comma-separated list of keywords. Example: "Lara, 25 years old, Brazilian, blonde long hair, blue eyes, athletic body"`;

        const payload = { contents: [{ role: "user", parts: [{ text: systemPrompt }] }] };

        try {
            const baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent`;
            const response = await fetchWithRetry(baseUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const result = await response.json();
            const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            return text ? `(character sheet for consistency: ${text.trim()})` : '';
        } catch (error) {
            console.error("Failed to generate consistency text with API:", error);
            showToast("Falha ao gerar consistência com IA.", 4000, true);
            return '';
        } finally {
            loadingOverlay.classList.add('hidden');
        }
    }

    async function addConsistencyText() {
        const button = document.getElementById('addConsistencyButton');
        if (button) button.disabled = true;
        try {
            const promptTextarea = document.getElementById('finalPrompt');
            const consistencyText = await generateConsistencyWithAPI(promptTextarea.value);
            if (consistencyText && !promptTextarea.value.includes("character sheet for consistency")) {
                promptTextarea.value += ` ${consistencyText}`;
                showToast("Texto de consistência adicionado!");
            } else if (!consistencyText) {
                showToast("Não foi possível gerar texto de consistência.", 3000, true);
            }
        } finally {
            if (button) button.disabled = false;
        }
    }

    function removeConsistencyText() {
        const promptTextarea = document.getElementById('finalPrompt');
        const originalText = promptTextarea.value;
        const newText = originalText.replace(/\s*\(character sheet for consistency:.*?\)/g, '').trim();
        
        if (originalText !== newText) {
            promptTextarea.value = newText;
            showToast("Texto de consistência removido!");
        } else {
            showToast("Nenhum texto de consistência para remover.", 3000, true);
        }
    }
    
    async function generateNegativePromptWithAPI(positivePrompt) {
        const systemPrompt = `You are an expert prompt engineer. Based on the user's positive prompt, create a standard but effective negative prompt in English. The goal is to prevent common image generation issues and reinforce the positive prompt's style. The negative prompt should be a comma-separated list of keywords. 
1. Include standard terms to prevent deformities: ugly, tiling, poorly drawn hands, poorly drawn face, out of frame, extra limbs, disfigured, deformed, body out of frame, bad anatomy, watermark, signature, cut off, low contrast, underexposed, overexposed, bad art, beginner, amateur, distorted face.
2. Analyze the positive prompt for key styles (e.g., 'photorealistic', 'anime', 'painting') and add contradictory terms to the negative prompt (e.g., if positive is 'photorealistic', add 'painting, drawing, illustration, anime').

Positive Prompt: "${positivePrompt}"

Respond with ONLY the comma-separated list of negative keywords.`;

        const payload = { contents: [{ role: "user", parts: [{ text: systemPrompt }] }] };

        try {
            const baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent`;

            const response = await fetchWithRetry(baseUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const result = await response.json();
            const negativeText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (negativeText) return negativeText.trim();
            throw new Error("Malformed API response for negative prompt.");
        } catch (error) {
            console.error("Failed to generate negative prompt with API:", error);
            showToast("Falha ao gerar prompt negativo com IA. Usando padrão.", 4000, true);
            return "deformed, bad anatomy, disfigured, poorly drawn face, mutation, mutated, extra limb, ugly, poorly drawn hands, missing limb, floating limbs, disconnected limbs, malformed hands, blurry, ((((mutated hands and fingers)))), watermark, watermarked, oversaturated, censored, distorted hands, amputation, missing hands, obese, doubled face, doubled hands, text, signature";
        }
    }

    async function handleRegenerateNegative() {
        const button = document.querySelector('[data-action="regenerate-negative"]');
        const positivePromptTextarea = document.getElementById('finalPrompt');
        const negativePromptTextarea = document.getElementById('negativePrompt');

        if (!positivePromptTextarea.value) {
            showToast("O prompt positivo está vazio. Não é possível gerar um negativo.", 4000, true);
            return;
        }

        if (button) button.disabled = true;
        loadingOverlay.classList.remove('hidden');
        loadingText.textContent = "Gerando novo prompt negativo...";

        try {
            const newNegativePrompt = await generateNegativePromptWithAPI(positivePromptTextarea.value);
            negativePromptTextarea.value = newNegativePrompt;
            lastNegativePrompt = newNegativePrompt; // Update the state
            showToast("Novo prompt negativo gerado com sucesso!");
        } catch (error) {
            console.error("Error regenerating negative prompt:", error);
            showToast("Falha ao gerar o novo prompt negativo.", 4000, true);
        } finally {
            loadingOverlay.classList.add('hidden');
            if (button) button.disabled = false;
        }
    }

    async function generateAndDisplayManualPrompt() {
        const generateButton = document.getElementById('nextButton');
        if (generateButton) generateButton.disabled = true;

        try {
            goToStep(23);
            isFinalPromptGenerated = true;
            isEditingFromTechSheet = false;
            
            // Clear the auto-generated idea if we are in a manual flow
            delete promptData.ai_generated_input;

            await new Promise(resolve => setTimeout(resolve, 0));
            
            const finalPromptTextarea = document.getElementById('finalPrompt');
            const negativePromptTextarea = document.getElementById('negativePrompt');
            
            finalPromptTextarea.value = "";
            negativePromptTextarea.value = "";
            
            loadingOverlay.classList.remove('hidden');
            loadingText.textContent = "Analisando suas escolhas...";

            const choicesSummary = summarizeChoices(promptData);
            const positivePrompt = await generateManualPromptWithAPI(choicesSummary);

            if (!positivePrompt) {
                if (generateButton) generateButton.disabled = false;
                return;
            }

            lastPositivePrompt = positivePrompt;
            finalPromptTextarea.value = positivePrompt;
            
            loadingText.textContent = "Gerando prompt negativo com IA...";

            const negativePrompt = await generateNegativePromptWithAPI(positivePrompt);
            lastNegativePrompt = negativePrompt;
            negativePromptTextarea.value = negativePrompt;

            document.getElementById('consistencySeed').textContent = Math.floor(Math.random() * 999999999999999);
        } catch (error) {
             console.error("Error during final prompt generation:", error);
             showToast("Um erro ocorreu ao gerar o prompt final.", 4000, true);
             if (generateButton) generateButton.disabled = false;
        } finally {
            loadingOverlay.classList.add('hidden');
        }
    }

    async function handleAutoGenerate(textOverride) {
        const generateButton = document.querySelector('[data-action="generate-auto"]');
        if(generateButton) generateButton.disabled = true;
        
        const userText = textOverride || document.getElementById('autoPromptManual').value.trim();
        if (!userText) {
            showToast("Por favor, descreva sua ideia no campo de texto.", 3000, true);
            if(generateButton) generateButton.disabled = false;
            return;
        }

        loadingOverlay.classList.remove('hidden');
        loadingText.textContent = "Analisando sua ideia...";
        
        promptData = {};
        isFinalPromptGenerated = false;

        const systemPrompt = `Você é um engenheiro de prompt profissional. Sua tarefa é pegar a ideia de um usuário e expandi-la para um prompt positivo e um negativo, ambos em inglês.

**Ideia do Usuário:** "${userText}"

**Instruções:**
1.  **Expanda o Prompt Positivo:** Elabore a ideia com detalhes sobre assunto, estilo, ambiente e qualidade.
2.  **Crie o Prompt Negativo:** Gere uma lista de termos para evitar problemas comuns (deformidades, má qualidade, etc.).
3.  **Formato de Saída:** Sua resposta DEVE SER APENAS um objeto JSON válido, sem nenhum texto ou formatação adicional antes ou depois. O JSON deve ter a seguinte estrutura: \`{"positive_prompt": "...", "negative_prompt": "..."}\`.`;

        const payload = {
            contents: [{ role: "user", parts: [{ text: systemPrompt }] }]
        };

        loadingText.textContent = "Gerando prompts detalhados...";
        
        try {
            const baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent`;
            
            const response = await fetchWithRetry(baseUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) throw new Error(`API Error: ${response.status} ${response.statusText}`);

            const result = await response.json();
            const contentPart = result?.candidates?.[0]?.content?.parts?.[0];
            
            if (contentPart && contentPart.text) {
                let jsonString = contentPart.text;
                const jsonMatch = jsonString.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonString = jsonMatch[0];
                }

                try {
                    const parsedJson = JSON.parse(jsonString);
                    goToStep(23);
                    document.getElementById('finalPrompt').value = parsedJson.positive_prompt || "Falha ao extrair prompt positivo.";
                    document.getElementById('negativePrompt').value = parsedJson.negative_prompt || "Falha ao extrair prompt negativo.";
                    document.getElementById('consistencySeed').textContent = Math.floor(Math.random() * 999999999999999);
                    isFinalPromptGenerated = true;
                    promptData['ai_generated_input'] = {label: userText, value: userText};
                    updateTechSheet();
                } catch (e) {
                    console.error("Failed to parse JSON from API response:", contentPart.text, e);
                    throw new Error("A API retornou uma resposta em formato inesperado.");
                }
            } else {
                const blockReason = result?.promptFeedback?.blockReason;
                if (blockReason) {
                    console.error("API call blocked. Reason:", blockReason, result.promptFeedback);
                    throw new Error(`A solicitação foi bloqueada pela API. Motivo: ${blockReason}`);
                }
                throw new Error("Resposta da API malformada ou vazia.");
            }

        } catch (error) {
            console.error("Falha na geração automática de prompt:", error);
            showToast(error.message || "Ocorreu um erro ao gerar o prompt com a IA. Tente novamente.", 5000, true);
            goToStep(0);
        } finally {
            loadingOverlay.classList.add('hidden');
            if(generateButton) generateButton.disabled = false;
        }
    }
    
    async function generateOptionsWithAI(stepId) {
        const stepData = stepsData[stepId];
        const generateButton = document.querySelector(`button[data-action="generate-options"][data-step-id="${stepId}"]`);
        if(generateButton) generateButton.disabled = true;

        const input = document.getElementById(`ai-input-${stepId}`);
        const container = document.getElementById(`ai-options-container-${stepId}`);
        const userInput = input.value.trim();

        if (!userInput) {
            showToast("Por favor, digite uma opção ou quantidade.", 3000, true);
            if(generateButton) generateButton.disabled = false;
            return;
        }

        loadingOverlay.classList.remove('hidden');
        loadingText.textContent = "Gerando opções com IA...";
        container.innerHTML = '';
        input.value = '';

        const baseCategory = promptData.baseCategory?.value === 'illustration' ? 'ilustração' : 'fotografia';
        const systemPrompt = stepData.aiPrompt(userInput, baseCategory);

        const payload = {
            contents: [{ role: "user", parts: [{ text: systemPrompt }] }],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "label": { "type": "STRING" },
                            "description": { "type": "STRING" },
                            "value": { "type": "STRING" },
                            "type": { "type": "STRING" }
                        },
                        required: ["label", "value"]
                    }
                }
            }
        };

        try {
            const baseUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent`;
            const response = await fetchWithRetry(baseUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            
            const result = await response.json();
            const contentPart = result?.candidates?.[0]?.content?.parts?.[0];

            if (contentPart && contentPart.text) {
                const options = JSON.parse(contentPart.text);
                aiGeneratedOptionsCache[stepId] = options;

                if (stepData.type === 'clothing-builder') {
                    options.forEach(opt => {
                        const card = document.createElement('div');
                        card.className = 'option-card p-4 rounded-lg cursor-pointer';
                        card.dataset.action = 'select-clothing-item';
                        card.dataset.label = opt.label;
                        card.dataset.value = opt.value;
                        card.dataset.type = opt.type;
                        card.innerHTML = `<h3 class="font-bold text-lg">${opt.label}</h3><p class="text-sm text-gray-400 mt-1">${opt.description}</p>`;
                        container.appendChild(card);
                    });
                } else {
                    options.forEach(opt => {
                        const card = createOptionCard(opt, stepData);
                        container.appendChild(card);
                    });
                }
            } else {
                 throw new Error("Resposta da API malformada ou vazia.");
            }
        } catch (error) {
            console.error("Falha ao gerar opções com IA:", error);
            showToast("Ocorreu um erro ao gerar as opções. Tente novamente.", 5000, true);
        } finally {
            loadingOverlay.classList.add('hidden');
            if(generateButton) generateButton.disabled = false;
        }
    }

    function updateTechSheet() {
        const hasData = Object.keys(promptData).length > 0;
        if (!hasData) {
            techSheetBar.classList.remove('visible');
            return;
        }

        techSheetContent.innerHTML = '';
        const isAutoFlow = !!promptData.ai_generated_input;
        const displayOrder = ['ai_generated_input', ...Object.keys(sidebarLabels).filter(k => k !== 'ai_generated_input')];

        displayOrder.forEach(key => {
            const data = promptData[key];
            if (!data) return;
            
            const label = sidebarLabels[key] || 'Gerado por IA';
            let valueText = '';

            if (key === 'clothing') {
                valueText = summarizeChoices({clothing: data}).replace('Vestimenta: ', '');
            } else {
                valueText = Array.isArray(data) ? data.map(i => i.label).join(', ') : data.label;
            }
            
            if (!valueText) return;

            const entry = document.createElement('div');
            entry.dataset.key = key;
            
            if (isAutoFlow) {
                entry.className = (key === 'ai_generated_input') ? 'tech-sheet-entry clickable' : 'tech-sheet-entry';
            } else {
                entry.className = 'tech-sheet-entry clickable';
                let stepId;
                if (key === 'lighting') {
                    stepId = promptData.baseCategory?.value === 'illustration' ? 100 : 20;
                } else {
                    stepId = Object.keys(stepsData).find(id => {
                        const s = stepsData[id];
                        if (s.key === key) return true;
                        if (s.inputs?.some(input => input.key === key)) return true;
                        if (s.manualInput?.key === key) return true;
                        if (s.sections?.some(sec => sec.key === key)) return true;
                        if (s.type === 'conditional-choice') {
                            return s.true?.key === key || s.false?.key === key;
                        }
                        return false;
                    });
                }
                if (stepId) entry.dataset.step = stepId;
            }
            
            entry.innerHTML = `<span class="font-semibold text-indigo-400 mr-2">${label}:</span> <span class="truncate">${valueText}</span>`;
            techSheetContent.appendChild(entry);
        });

        regenerateButton.style.display = isFinalPromptGenerated ? 'flex' : 'none';
        returnToPromptButton.style.display = isFinalPromptGenerated ? 'flex' : 'none';
    }


    document.addEventListener('DOMContentLoaded', () => {
        restart();
    });

    </script>
</body>
</html>
